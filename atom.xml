<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-05T16:22:03.936Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：11、二分查找算法，折半查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example11/</id>
        <link href="https://acoldfront.github.io/post/c-example11/">
        </link>
        <updated>2020-05-05T13:11:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：10、归并排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example10/</id>
        <link href="https://acoldfront.github.io/post/c-example10/">
        </link>
        <updated>2020-05-05T13:10:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>归并排序的基本原理是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。其实通俗来说，对于一个数来说自身是有序的，然后每次选取两个数使之自身有序，然后每次选取四个数使之自身有序，以后以二倍增长选择，进行排序。将若将两有个有序表合成一个有序表，成为二路归并。（具体可以依据下图进行分析）</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：15、2、35、6、23、11、5<br>
说明：其中s1,s2,e1,e2 分别表示两个归并段的首尾位置，brr[]为辅助数组，arr[]为存储结果的数组。<br>
具体步骤：<br>
<img src="https://acoldfront.github.io//post-images/1588695126632.png" alt="" loading="lazy"></p>
<p><strong>实现过程：</strong><br>
(1) 自定义函数 merge()，实现一次归并排序。</p>
<p>(2) 自定义函数 merge_sort()，实现归并排序。</p>
<p>(3) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int merge(int r[], int s[], int x1, int x2, int x3) {   //自定义实现一次归并样序的函数

    int i, j, k;
    i = x1;    //第一部分的开始位置
    j = x2 + 1;  //第二部分的开始位置
    k = x1;
    while ((i &lt;= x2) &amp;&amp; (j &lt;= x3))    //当i和j都在两个要合并的部分中时
        if (r[i] &lt;= r[j])    //筛选两部分中较小的元素放到数组s中
        {
            s[k] = r[i];
            i++;
            k++;
        } else {
            s[k] = r[j];
            j++;
            k++;
        }
    while (i &lt;= x2)    //将x1〜x2范围内未比较的数顺次加到数组r中
        s[k++] = r[i++];
    while (j &lt;= x3) //将x2+l〜x3范围内未比较的数顺次加到数组r中
        s[k++] = r[j++];
    return 0;
}

int merge_sort(int r[], int s[], int m, int n) {
    int p;
    int t[20];
    if (m == n)
        s[m] = r[m];
    else {
        p = (m + n) / 2;
        merge_sort(r, t, m, p);    //递归调用merge_soit()函数将r[m]〜r[p]归并成有序的t[m]〜t[p]
        merge_sort(r, t, p + 1, n);    //递归一调用merge_sort()函数将r[p+l]〜r[n]归并成有序的t[p+l]〜t[n]
        merge(t, s, m, p, n);    //调用函数将前两部分归并到s[m]〜s[n】*/
    }
    return 0;
}

int main(void) {
    int a[11];
    int i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //从键盘中输入10个数
    merge_sort(a, a, 1, 10);    //调用merge_sort()函数进行归并排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数据
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
695 458 362 789 12 15 163 23 2 986
排序后的顺序是：
    8   12   15   23  163  362  458  695  789  986
</code></pre>
<hr>
<p>** 方法二 **</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void Merge(int *arr,int len,int gap)
{
    int *brr = (int *)malloc(sizeof(int) * len);  //动态开辟辅助数组
    assert(brr != NULL);
    int i = 0;           //brr的下标
    int start1 = 0;
    int end1 = start1+gap-1;
    int start2 = end1+1;
    int end2 = start2 + gap - 1 &lt; len - 1 ? start2 + gap - 1 : len - 1 ;     //当有两个归并段的时候
    while(start2 &lt; len)
    {
        //当两个归并段还没有比较完的时候
        while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        {
            if(arr[start1] &lt;= arr[start2])
            {
                brr[i++] = arr[start1++];
            }
            else
            {
                brr[i++] = arr[start2++];
            }
        }
        while(start1 &lt;= end1)     //如果是第二个归并段比较完了，则将第一个归并段中的数放在brr[]
        {
            brr[i++] = arr[start1++];
        }
        while(start2 &lt;= end2)  //如果是第一个归并段比较完了，则将第二个归并段中的数放在brr[]
        {
            brr[i++] = arr[start2++];
        }
        //找两个新的归并段
        start1 = end2+1;
        end1 = start1+gap-1;
        start2 = end1+1;
        end2 = start2+gap-1 &lt; len-1?start2+gap-1:len-1;
    }
    while(start1 &lt; len)  //如果在最后不存在第二个归并段，则将第一个归并段中的数放在brr[]
    {
        brr[i++] = arr[start1++];
    }
    for(int i = 0;i &lt; len;i++)    //数值拷贝
    {
        arr[i] = brr[i];
    }
}
void MergeSort(int *arr,int len)
{
    for(int i = 1;i &lt; len;i *= 2)   //i表示分组数，分组形式为1 2 4 8....
    {
        Merge(arr,len,i);
    }
}

int main(void) {
    int a[11];
    int i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //从键盘中输入10个数
    MergeSort(a,10);    //调用merge_sort()函数进行归并排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数据
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>归并是将两个或多个存序记录序列合并成一个有序序列。归并方法有多种，一次对两个有序记录序列进行归并，称为路归并排序，也有三路归并排序及多路归并排序。本实例是二路归并排序，基本方法如下：</p>
<p>(1) 将 n 个记录看成是 n 个长度为 1 的有序子表。</p>
<p>(2) 将两两相邻时有序无表进行归并。</p>
<p>(3) 重复执行步骤 (2) 直到归并成一个长度为 n 的有序表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：9、选择排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example9/</id>
        <link href="https://acoldfront.github.io/post/c-example9/">
        </link>
        <updated>2020-05-05T13:10:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>选择排序的基本原理是以序列首元素位置为基准位置，每次将该基准位置的元素和后面元素逐个进行比较，挑选最大或者最小的那个数放在基准位置上，一趟比较结束后，然后将基准位置设置为该位置的下一位置，重复上述操作，直到基准被安排在序列的最后有一个位置时，此时序列已经排列完成。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：88、5、15、56、32、18、69<br>
说明：按照从小到大的顺序进行排序，其中每条彩色线条为两数之间的比较,其条数为比较次数.图示为比较结果,过程较为简单,请读者自行分析.<br>
(1)第一躺比较：<br>
<img src="https://acoldfront.github.io//post-images/1588694020653.png" alt="" loading="lazy"><br>
此时最小数5已经放在最开始的位置。<br>
(2)第二趟比较：<br>
<img src="https://acoldfront.github.io//post-images/1588694033043.png" alt="" loading="lazy"><br>
此时将第二小的数字放在当前序列的开头<br>
(3)第三趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588694046856.png" alt="" loading="lazy"><br>
此时将第三小的数字放在当前序列的开头<br>
以此类推，可得到最终结果为：5、15、18、32、56、69、88</p>
<p><strong>实现过程：</strong><br>
(1) 程序中用到T两个 for 循环语句。第一个 for 循环是确定位置的，该位置是存放每次从待排序数列中经选择和交换后所选出的最小数。第二个 for 循环是实现将确定位置上的数与后面待排序区间中的数进行比较的。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void Selset_Sort(int s[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n; ++i) {
        for (j = i + 1; j &lt; n; ++j) {
            if (s[i] &gt; s[j]) {  //如果前一个数比后一个数大，则利用中间变量t实现两值互换
                temp = s[i];
                s[i] = s[j];
                s[j] = temp;
            }
        }
    }
}

int main(void) {
    int b[10], j;
    printf(&quot;请输入10个数：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        scanf(&quot;%d&quot;, &amp;b[j]);
    Selset_Sort(b, 10);         //调用快速排序函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        printf(&quot;%-4d&quot;, b[j]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
526 36 2 369 56 45 78 92 125 52
排序后的顺序是：
2   36  45  52  56  78  92  125 369 526
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>选择排序的基本算法是从待排序的区间中经过选择和交换后选出最小的数值存放到 a[0] 中，再从剩余的未排序区间中经过选择和交换后选出最小的数值存放到 a[1] 中，a[1] 中的数字仅大于 a[0]，依此类推，即可实现排序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：8、快速排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example8/</id>
        <link href="https://acoldfront.github.io/post/c-example8/">
        </link>
        <updated>2020-05-05T13:09:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>快速排序算法的基本原理为通过一次排序将要排序的数据分割成独立的两部分，将序列分为两部分的中间数作为基准(par)，基准左边的数都要比基准右边的数要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：8，15，26，18，7，66，44<br>
分析：依靠基准将序列分割为两部分，那么基准如何找到呢？？？？？？<br>
方法有三种：</p>
<p>固定位置选取基准法              <br>
随机选取基准法<br>
三分取中法<br>
具体步骤：<br>
一次取基准(par)过程：设置一个临时变量temp，并以第一个数作为temp的值，设置两个指针low和high。low指向序列的起始位置，high指向序列的最后一个元素。首先我们用high指向的元素和temp进行比较，如果大于，指针回退，直到high指向的元素值小于temp，然后让low指向的值赋值为high的值。这时让low指向的元素和temp比较，如果low指向的元素小于temp，指针前进，直到low指向的元素值大于temp。这时让high指向的值赋值为low指向的值，接下来对high重复上述操作，直到high和low相遇。此时的位置就是基准的位置par，最后此位置赋值temp。（具体可依据下图进行分析）</p>
<p>说明：</p>
<ul>
<li>下图每一步为指针的循环操作，直至不符合条件，并且进行赋值变换后的结果。</li>
<li>上述一次取基准的过程采用了固定位置选取基准法。（另外两种方法后面将进行介绍）<br>
<img src="https://acoldfront.github.io//post-images/1588691937722.png" alt="" loading="lazy"><br>
然后对左右两部分子序列继续进行此步骤。（如果子序列为单个数时，说明自身有序，不进行此过程）</li>
</ul>
<p><strong>实现过程：</strong><br>
(1) 自定义一个函数，实现直接插入排序，在本实例中，我们自定义该函数为 insort()。</p>
<p>(2) main() 函数为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int qusort(int s[], int start, int end) {    //自定义函数 qusort()
    int i, j;    //定义变量为基本整型
    i = start;    //将每组首个元素赋给i
    j = end;    //将每组末尾元素赋给j
    s[0] = s[start];    //设置基准值
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; s[0] &lt; s[j])
            j--;    //位置左移
        if (i &lt; j) {
            s[i] = s[j];    //将s[j]放到s[i]的位置上
            i++;    //位置右移
        }
        while (i &lt; j &amp;&amp; s[i] &lt;= s[0])
            i++;    //位置左移
        if (i &lt; j) {
            s[j] = s[i];    //将大于基准值的s[j]放到s[i]位置
            j--;    //位置左移
        }
    }
    s[i] = s[0];    //将基准值放入指定位置
    if (start &lt; i)
        qusort(s, start, j - 1);    //对分割出的部分递归调用qusort()函数
    if (i &lt; end)
        qusort(s, j + 1, end);
    return 0;
}

int main(void) {
       int a[10], i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    QuickSort(a, 0, 9);    //调用qusort()函数进行排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        printf(&quot;%5d&quot;, a[i]);    //将排序后的顺序输出
    }

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
99 45 12 36 69 22 62 796 4 696
排序后的顺序是：
    4   12   22   36   45   62   69   99  696  796
</code></pre>
<hr>
<h3 id="快速排序原理">快速排序原理：</h3>
<p>从序列“2,3,5,7,9,6,4,1,0,8”两端开始<br>
（1）首先将2作为基准数，应用2个变量i和j分别指向序列左端和右端；<br>
（2）首先从j左往右寻找一个小于2的数，i从右往左寻找一个大于2的数；<br>
（3）找到了0和3进行第一次交换，继续搜索；<br>
（4）1和5进行第二次交换；<br>
（5）当i和j都到1数值1时，表明第一轮交换结束，将基准数2和1进行交换，以基准数2为分界点，2的左边都小于等于2,2的右边都大于等于2；<br>
（6）2的左边序列为“1,0”，2的右边序列为“7,9,6,4,5,3,8”；<br>
（7）最后调用递归分别处理左边序列和右边序列即可。<br>
<img src="https://acoldfront.github.io//post-images/1588693747080.png" alt="" loading="lazy"></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void QuickSort(int a[], int left, int right) {
    int i, j, temp, tp;
    temp = a[left];                 //暂存基准数
    i = left;                       //最左位置
    j = right;                      //最右位置

    if (left &gt; right)                //递归结束条件
        return;
    while (i != j)                  //当i和j不重合时
    {
        while (a[j] &gt;= temp &amp;&amp; i &lt; j) //从右往左寻找小于基准数的值
            j--;
        while (a[i] &lt;= temp &amp;&amp; i &lt; j) //从左往右寻找大于基准数的值
            i++;
        //找到了且i&lt;j则交换数值
        if (i &lt; j) {
            tp = a[i];
            a[i] = a[j];
            a[j] = tp;
        }
    }

    //将基准数和i、j的相遇数值进行交换
    a[left] = a[i];
    a[i] = temp;

    //应用递归对此时基准数的左边进行快速排序
    QuickSort(a, left, i - 1);
    //应用递归对此时基准数的右边进行快速排序
    QuickSort(a, i + 1, right);
}

int main(void) {
    int b[10], j;
    printf(&quot;请输入10个数：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        scanf(&quot;%d&quot;, &amp;b[j]);
    QuickSort(b, 0, 9);         //调用快速排序函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        printf(&quot;%-4d&quot;,b[j]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
99 45 12 36 69 22 62 796 4 696
排序后的顺序是：
    4   12   22   36   45   62   69   99  696  796
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>快速排序是冒泡排序的一种改进，主要的算法思想是在待排序的 n 个数据中取第一个数据作为基准值，将所有记录分为 3 组，使第一组中各数据值均小于或等于基准值，第二组做基准值的数琚，第三组中各数据值均大于或等于基准值。这便实现了第一趟分割，然后再对第二组和第兰组分别重复上述方法，依次类推，直到每组中只有一个记录为止。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：7、直接插入排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example7/</id>
        <link href="https://acoldfront.github.io/post/c-example7/">
        </link>
        <updated>2020-05-05T13:09:08.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>直接插入排序的基本原理就如同打扑克牌一样，起初在摸牌的时候，第一张牌对于自身而言是有序的，假如摸到4，当第二次摸到6时，会将6放在4的后面，第三次摸到3时，会将3放在4的前面，这个过程就是直接插入排序。那么对于6和3而言，如何知道是大还是小呢？过程很简单，每摸到一张牌就和前面已有序数列作比较比较，然后交换顺序即可。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如:8、45、18、33、15、99、3<br>
说明：按照从小到大的顺序进行排序。</p>
<p>具体实现步骤如下：设置一个临时变量temp，其值为当前所摸牌的值，然后和它的前一张牌（即已有序列的最后一张牌）开始比较，如果temp小于前一张牌的值，就把前一张牌放在当前位置，结果比较有序序列的倒数第二位置，如果再小，重复上述步骤，如果大于，由于比较的是有序序列，故此是为有序状态，最后把temp的值放在和有序序列中最后一个比较的值的下一位置当有序之后，退出循环。具体可根据下述图进行自行分析。<br>
备注：</p>
<ul>
<li>其中i表示当前所摸的牌，j表示已有序数列的最后一张牌，从后往前比较。</li>
<li>其中蓝色空格为temp的值,不代表方框中的值,彩色线条为两数之间的比较。</li>
<li>以下每一步均为比较完变化后的结果。<br>
(1)第一趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689732582.png" alt="" loading="lazy"><br>
(2)第二趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588690023139.png" alt="" loading="lazy"><br>
以此类推...<br>
(3)第六趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689972515.png" alt="" loading="lazy"><br>
此时待排序列已全部有序。<br>
拓展：n个数排序需要n - 1躺。</li>
</ul>
<p><strong>实现过程：</strong><br>
(1) 自定义一个函数，实现直接插入排序，在本实例中，我们自定义该函数为 insort()。</p>
<p>(2) main() 函数为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int insort(int s[], int n) {    //自定义函数 insort()
    int i, j, temp;
    for (i = 1; i &lt; n; ++i) {   //由于temp的初值为第二个数，故i为1
        temp = s[i];
        for (j = i - 1; j &gt;= 0; j--) {
            if (s[j] &gt; temp) {
                s[j + 1] = s[j];
            } else {
                break;
            }
        }
        s[j + 1] = temp;
    }
    return 0;
}

int main(void) {
    int a[10], i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    insort(a, 10);
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        printf(&quot;%5d&quot;, a[i]);    //将排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
25 12 36 45 2 9 39 22 98 37
排序后的顺序是：
    2    9   12   22   25   36   37   39   45   98
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>直接插入排序是将一个数与一组已排号顺序的序列中的最后一个数进行比较。直接插入排序是一种稳定的排序算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：6、冒泡排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example6/</id>
        <link href="https://acoldfront.github.io/post/c-example6/">
        </link>
        <updated>2020-05-05T04:19:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>冒泡排序是一种较为简单的排序算法，其基本思想为从头开始依次比较相邻的两个元素大小，将较大（较小）的元素移至右端，最终使最大（最小）的元素移至序列最后，再次重复上述过程，直到最终序列完全有序为止。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：有一行数分别是26、10，83，56，28，66，7<br>
说明：按照从小到大的顺序进行排序，方框数为比较的次数，以下图示为比较完交换的结果。</p>
<p>(1)第一躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688650202.png" alt="" loading="lazy"><br>
此时已将此行数中最大的那个数字放在末尾。<br>
(2)第二躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688660796.png" alt="" loading="lazy"><br>
此时将倒数第二大的数字放在后面。<br>
(3)第三趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688685619.png" alt="" loading="lazy"><br>
此时将倒数第三大的数字放在后面。<br>
以此类推，可以得到最终结果为：7、10、26、28、56、66、83。<br>
备注：n个数要比较n - 1趟，第一躺比较n - 1次，第 j 趟需要比较n - j 次。</p>
<p><strong>实现过程：</strong><br>
(1) 通过两个 for 循环实现冒泡排序的全过程，外层 for 循环决定冒泡排序的趟数，内层 for 循环决定每趟所进行两两比较的次数。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, tmp, a[10];    //定义变量及数组为基本整型
    printf(&quot;请输入10个数：\n&quot;);
    for (int i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    for (i = 1; i &lt; 10; ++i) {  //变量i代表比较的趟数
        for (j = 0; j &lt; 10 - i; ++j) {  //变最j代表每趟两两比较的次数
            if (a[j] &gt; a[j + 1]) {
                tmp = a[j]; //产利用中间变童实现两值互换
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }

    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //将冒泡排序后的顺序输出
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<hr>
<p><strong>改进版冒泡排序：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    //改进版冒泡排序
    int x, y, flag, tmp1, b[10];
    printf(&quot;请输入10个数：\n&quot;);
    for (int x = 0; x &lt; 10; ++x) {
        scanf(&quot;%d&quot;, &amp;b[x]);//从键盘中输入10个数
    }
    for (x = 1; x &lt; 10; ++x) {
        flag = 0;       //假设第x行没有交换数据，flag=0
        for (y = 0; y &lt; 10 - x; ++y) {
            if (b[y] &gt; b[y + 1]) {
                tmp1 = b[y];
                b[y] = b[y + 1];
                b[y + 1] = tmp1;
                flag = 1;   //交换数据，flag=1
            }
        }
        if (0 == flag) {    //若flag=0，表明第x行没有交换数据
            break;
        }
    }
    printf(&quot;排序后的顺序是：\n&quot;);
    for (x = 0; x &lt; 10; x++) {
        printf(&quot;%5d&quot;, b[x]);    //将冒泡排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例要求用冒泡法对 10 个数由小到大进行排序，冒泡法的基本思路是，如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第 1 趟比较中要进行 n-j 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较。从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：5、希尔排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example5/</id>
        <link href="https://acoldfront.github.io/post/c-example5/">
        </link>
        <updated>2020-05-05T04:11:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)自定义函数 shsort()，实现希尔排序。</p>
<p>(2) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int shsort(int s[], int n) {
    int i, j, d;
    d = n / 2;    //确定固定增虽值
    while (d &gt;= 1) {
        for (i = d + 1; i &lt;= n; ++i) {    //数组下标从d+1开始进行直接插入排序
            s[0] = s[i];  //设置监视哨
            j = i - d;  //确定要进行比较的元素的最右边位置
            while ((j &gt; 0) &amp;&amp; (s[0] &lt; s[j])) {
                s[j + d] = s[j];    //数据右移
                j = j - d;  //向左移d个位置
            }
            s[j + d] = s[0];    //在确定的位罝插入s[i]
        }
        d = d / 2;    //增里变为原来的一半
    }
    return 0;
}

int main(void) {
    int a[11], i;    //定义数组及变量为基本整型
    printf(&quot;请输入 10 个数据：\n&quot;);
    for (i = 1; i &lt;= 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);  //从键盘中输入10个数据
    }
    shsort(a, 10);    //调用 shsort()函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数组
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入 10 个数据：
69 56 12 136 3 55 46 99 88 25
排序后的顺序是：
    3   12   25   46   55   56   69   88   99  136
</code></pre>
<hr>
<p>** 方法二 **</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void ShellSort(int a[], int n) {
    int i, j, temp;
    int flag, gap = n;
    while (gap &gt; 1) {
        gap = gap / 2;              //每次减半
        flag = 1;
        while (flag) {
            flag = 0;
            for (i = 0; i &lt; n - gap; i++) {
                j = i + gap;
                if (a[i] &gt; a[j]) {
                    temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                    flag = 1;
                }
            }
        }
    }
}

int main(void) {
    int a[10], i;
    printf(&quot;请输入 10 个数据：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    printf(&quot;排序前的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%-4d&quot;, a[i]);
    ShellSort(a, 10);
    printf(&quot;\n排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%-4d&quot;, a[i]);
    printf(&quot;\n&quot;);
    return 0;
</code></pre>
<p>输出结果：</p>
<pre><code>请输入 10 个数据：
69 56 12 136 3 55 46 99 88 25
排序前的顺序是：
69  56  12  136 3   55  46  99  88  25
排序后的顺序是：
3   12  25  46  55  56  69  88  99  136
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>希尔排序是在直接插入排序的基础上做的改进，也就是将寒排序的序列按固定增量分成若干组，等距者在同二组中，然后再在组内进行直接插入排序。这里面的固定增量从 n/2 开始，以后每次缩小到原来的一半。<br>
<a href="https://blog.csdn.net/weixin_37818081/article/details/79202115">不懂希尔排序原理可以看</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：4、渔夫打鱼晒网]]></title>
        <id>https://acoldfront.github.io/post/c-example4/</id>
        <link href="https://acoldfront.github.io/post/c-example4/">
        </link>
        <updated>2020-05-05T03:58:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 自定义函数 leap()，用来判断输入的年份是否是闰年。</p>
<p>(2) 自定义函数 number()，用来计算输入日期距 2011 年 1 月 1 日共有多少天。</p>
<p>(3) main() 函数作为程序的入口函数，在 main() 函数中调用上面两个函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int leap(int a) {   //自定义函数leap()用来指定输入的年份是否为闰年
    if (a % 4 == 0 &amp;&amp; a % 100 != 0 || a % 400 == 0)    //闰年判定条件
        return 1;   //是闰年返回1
    else
        return 0;   //不是闰年返回O
}

int number(int year, int month, int day) {    //自定义函数 number() 计算输入日期距2011年1月1日共有多少天
    int sum = 0, i, j, k;
    int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组a存放平年每月的天数
    int b[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组b存放闰年每月的天数
    if (leap(year) == 1) {    //判断是否为闰年
        for (i = 0; i &lt; month - 1; ++i)
            sum += b[i];    //是闰年，累加数组b前m-1个月份的天数
    } else {
        for (i = 0; i &lt; month - 1; ++i)
            sum += a[i];    //不是闰年，累加数组a前m-1个月份的天数
    }
    for (j = 2011; j &lt; year; ++j) {
        if (leap(j) == 1)
            sum += 366;   //2011年到输入的年份是闰年的加366
        else
            sum += 365;   //2011年到输入的年份不是闰年的加365
    }
    sum += day;    //将前面累加的结果加上日期，求出总天数
    return sum; //返回计算的天数
}

int main(void) {
    int year, month, day, n;
    printf(&quot;请输入年月日\n&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;year, &amp;month, &amp;day);    //输入年月日
    n = number(year, month, day);
    if ((n % 5) &lt; 4 &amp;&amp; (n % 5) &gt; 0)    //余数是1或2或3时说明在打渔，否则在晒网
        printf(&quot;%d：%d：%d 打鱼\n&quot;, year, month, day);
    else
        printf(&quot;%d：%d：%d 晒网\n&quot;, year, month, day);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入年月日
2011 1 4
2011：1：4 晒网
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例主要有以下两个技术要点：</p>
<p>(1) 判断输入的年份（2011 年以后包括 2011 年）是否为闰年，这里自定义函数 leap() 来进行判断。该函数的核心内容就是闰年的判断条件即能被 4 整除但不能被 100 整除，或能被 400 整除。</p>
<p>(2) 求输入日期距 2011 年 1 月 1 日有多少天。首先判断 2011 年距输入的年份有多少年，这其中有多少年是闰年就将 sum 加多少个 366，有多少年是平年便将 sum 加上多少个 365。</p>
<p>其次要将 12 个月每月的天数存到数组中，因为闰年 2 月份的天数有别于平年，故采用两个数组 a 和 b 分别存储。若输入年份是平年，月份为 m 时就在前面累加日期的基础上继续累加存储着平年每月天数的数组的前 m-1 个元素，将累加结果加上输入的日期便求出了最终结果。闰年的算法类似。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：3、百元买鸡]]></title>
        <id>https://acoldfront.github.io/post/c-example3/</id>
        <link href="https://acoldfront.github.io/post/c-example3/">
        </link>
        <updated>2020-05-05T03:39:52.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)使用 for 语句对 3 种鸡的数嫌在事先确定好的范围内进行穷举并判断，对满足条件的 3 种鸡的数量按指定格式输出，否则进行下次循环。</p>
<p>(2) 程序的代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
   int cook, hen, chick;   //定义变童为基本整型

    for (cook = 0; cook &lt;= 100; ++cook) {
        for (hen = 0; hen &lt;= 100; ++hen) {
            for (chick = 0; chick &lt;= 100; ++chick) {
                if ((5 * cook + 3 * hen + chick / 3) == 100 &amp;&amp; chick % 3 == 0 &amp;&amp; cook+hen+chick==100)
                    //(5 * cook + 3 * hen + chick / 3) == 100   判断钱数是否等于 100
                    //chick % 3 == 0    判断小鸡数是否能被 3 整除
                    //cook+hen+chick==100  判断购买的鸡数是否等于 100
                    printf(&quot;公鸡 %2d 只，母鸡 %2d 只，小鸡 %2d 只\n&quot;, cook, hen, chick);
            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>公鸡  0 只，母鸡 25 只，小鸡 75 只
公鸡  4 只，母鸡 18 只，小鸡 78 只
公鸡  8 只，母鸡 11 只，小鸡 81 只
公鸡 12 只，母鸡  4 只，小鸡 84 只
</code></pre>
<p>###技术要点： ###<br>
根据题意设公鸡、母鸡和雏鸡分别为 cock、hen 和 chick，如果 100 元全买公鸡，那么最多能买 20 只，所以 cock 的范围是大于等于 0 且小于等于 20；如果全买母鸡，那么最多能买 33 只，所以 hen 的范围是大于等于 0 且小于等于 33；如果 100 元钱全买小鸡，那么最多能买 99 只（根据题意小鸡的数量应小于 100 且是 3 的倍数）。</p>
<p>在确定了各种鸡的范围后进行穷举并判断，判断的条件有以下 3 点：<br>
(1) 所买的 3 种鸡的钱数总和为 100。<br>
(2) 所买的 3 种鸡的数量之和为 100。<br>
(3) 所买的小鸡数必须是 3 的倍数。</p>
]]></content>
    </entry>
</feed>