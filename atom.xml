<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-07T08:33:25.979Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：20、判断闰年，即判断年份是否为闰年]]></title>
        <id>https://acoldfront.github.io/post/c-example20/</id>
        <link href="https://acoldfront.github.io/post/c-example20/">
        </link>
        <updated>2020-05-06T09:49:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
判断任意年份是否为闰年，需要满足以下条件中的任意一个：<br>
① 该年份能被 4 整除同时不能被 100 整除；<br>
② 该年份能被400整除。</p>
<p>本实例中使用嵌入式 if-else 语句。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int year, a;
    printf(&quot;请输人年份：&quot;);
    scanf(&quot;%d&quot;, &amp;year);
    if (((year % 4 == 0 )&amp;&amp; (year % 100 != 0)) || (year % 400 == 0))
        printf(&quot;%d 此年是闰年\n&quot;, year);
    else
        printf(&quot;%d 此年非闰年\n&quot;,year);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输人年份：1995
1995 此年非闰年

请输人年份：1996
1996 此年是闰年
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：19、求回文数、回文素数]]></title>
        <id>https://acoldfront.github.io/post/c-example19/</id>
        <link href="https://acoldfront.github.io/post/c-example19/">
        </link>
        <updated>2020-05-06T08:58:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
① 获取一个数，例如123<br>
② 求出321与123相比<br>
③ 求123中的个位数：3 -&gt; 123%10/1<br>
十位数：2 -&gt; 123%100/10<br>
百位数：1 -&gt; 123%1000/100<br>
通式：num  %(10*i)/i<br>
④将321 = 3 * 100 +2  * 10 + 1<br>
⑤定义一个snum用来存储倒置的数，即3snum = 21，snum = num % (10 * i) / i + 10 * snum;<br>
第一次循环：s = 3 + 0<br>
第二次循环：s = 2 + 30<br>
第三次循环：s = 1 + 320<br>
⑥对比num 和 snum的值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, num;
    int snum = 0;   //用来存放倒置的数
    intf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;num);
    for (i = 1; i &lt; num; i *= 10) {   //i每次增加10倍，实现个位，十位，百位。。。的转化换
        snum = num % (10 * i) / i + 10*snum;
        //s = 3 + 0
        //s = 2 + 30
        //s = 1 + 320
    }
    if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入一个整数：121
这个数是一个回文数
</code></pre>
<hr>
<blockquote>
<p>求 1000 以内的所有回文素数。</p>
</blockquote>
<p><strong>算法思想：</strong><br>
实例的重点是判断一个数是否是回文素数。要输出 1000 以内的所有回文素数，首先应判断这个数是否是素数；如果是，再进一步判断这个数是两位数还是三位数，若是两位数，则需判断个位数和十位数是否相同；若是三位数，则需判断个位数和百位数是否相同。若相同，则判断为回文素数，否则继续下次判断。</p>
<p>① 定义一个函数 sushu，其作用是判断一个数是否是素数。<br>
② 对判断为素数的数，再判断其是否是两位数。<br>
若是两位数，再判断其个位数和十位数是否相同，若相同则打印输出；若不相同，则执行④；若不是两位数，则执行③。<br>
③ 若是三位数，则判断其个位数和百位数是否相同。若相同，则打印输出；若不相同，则执行 ④。<br>
④ 循环控制变量 i 自增 1。<br>
⑤ 直到 i 自增至 1000 结束。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;stdio.h&gt;

/*判断参数n是否为素数*/
int fun(int n) {
    int i;
    for (i = 2; i &lt; (n - 1) / 2; ++i) {
        if (n % i == 0)
            return 0;
    }
    return 1;
}

int main(void) {
    int i;
    for (i = 10; i &lt; 1000; ++i) {   //10以内没有回文素数
        if (fun(i) == 1) {      //素数
            if (i / 100 == 0) {     //100以内的
                if (i / 10 == i % 10)   //对比十位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);
            } else {
                if (i / 100 == i % 10)  //对比百位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);

            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>   11  101  131  151  181  191  313  353  373  383  727  757  787  797  919  929
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 程序由 main() 函数和 sushu() 函数组成，main() 函数调用 sushu() 函数，整型变量 i 为函数参数。当 sushu () 执行完后，返回到主函数中继续执行被调函数后面的语句。</p>
<p>② 函数调用语句由函数名、实际参数加上分号“;”组成。其一般形式为“函数名(实际参数表);”。执行函数语句就是调用函数体并把实际参数赋予函数定义中的形式参数，然后执行被调函数体中的语句，求取函数值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：18、小写字母转换成大写字母]]></title>
        <id>https://acoldfront.github.io/post/c-example18/</id>
        <link href="https://acoldfront.github.io/post/c-example18/">
        </link>
        <updated>2020-05-06T08:56:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
由于大写字母与小写字母之间的差值为 32，因此小写字母转换为大写字母的方法就是将小写字母的 ASCII 码值减去 32，便可得到与之对应的大写字母。</p>
<p>利用 getchar 函数从键盘上输入一个小写字母，并将其赋给一个字符变量 a；然后将 a—32 的值赋给字符变量 b；最后进行输出，输出时先输出字母，再将字母以整数形式输出。其具体步骤如下：</p>
<p>① 定义两个字符变量 a、b；<br>
② a=get char()；<br>
③ b=a—32；<br>
④ 打印输出。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    char a, b;
    printf(&quot;输入一个小写字母:\n&quot;);
    a = getchar();
    b = a - 32;
    printf(&quot;转换后的字母为：%c，%d\n&quot;, b, b);
    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>输入一个小写字母:
c
转换后的字母为：C，67
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 实例内容要求对 ASCII 码有所了解。知道小写字母和大写字母之间的差值为 32。</p>
<p>② getchar 函数的功能是从键盘上输入一个字符。其一般形式为“getchar()”。通常把输入的字符赋予一个字符变量，构成赋值语句，如：char c;或c=getchar();</p>
<p>③ 使用 getchar 函数还应注意几个问题：<br>
getchar 函数只能接收单个字符，输入数字也按字符处理。输入多于一个字符时，只接收第一个字符。<br>
使用 getchar 函数前必须包含文件“stdio.h”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：17、求自然底数e]]></title>
        <id>https://acoldfront.github.io/post/c-example17/</id>
        <link href="https://acoldfront.github.io/post/c-example17/">
        </link>
        <updated>2020-05-06T04:16:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>自然底数 e=2.718281828…，e 的计算公式如下：<br>
e=1+1/1!+1/2!+1/3!+…<br>
要求当最后一项的值小于 10-10 时结束。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>自然底数 e=2.718281828…，e 的计算公式如下：<br>
e=1+1/1!+1/2!+1/3!+…<br>
要求当最后一项的值小于 10-10 时结束。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
使用循环实现累加求和，并在求和后计算下一项所对应的阶乘。</p>
<p>① 用循环语句 while 进行循环控制。判断条件为 1/n&gt;10-10；条件成立则执行 ②，条件不成立执行 ⑤；<br>
② 计算求和 e+=1/n；<br>
③ i 自增 1；<br>
④ 计算下一项所对应的阶乘：n=i*n；<br>
⑤ 结束循环，打印输出结果。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    float e = 1.0, n = 1.0;
    int i = 1;
    while (1 / n &gt; 1e-10) {
        e += 1 / n;
        i++;
        n = i * n;
    }
    printf(&quot;e的值是：%f\n&quot;,e);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>e的值是：2.718282
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：16、最大公约数和最小公倍数]]></title>
        <id>https://acoldfront.github.io/post/c-example16/</id>
        <link href="https://acoldfront.github.io/post/c-example16/">
        </link>
        <updated>2020-05-06T03:57:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入两个正整数 a 和 b，求其最大公约数和最小公倍数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入两个正整数 a 和 b，求其最大公约数和最小公倍数。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
利用格式输入语句将输入的两个数分别赋给 a 和 b，然后判断 a 和 b 的关系，如果 a 小于 b，则利用中间变量 t 将其互换。再利用辗转相除法求出最大公约数，进而求出最小公倍数。最后用格式输出语句将其输出。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最小公倍数
int _lcm(int a, int b) {
    int lcm;
    if (a &gt; b)
        lcm = a;
    else
        lcm = b;
    while (lcm % a || lcm % b)
        lcm++;
    return lcm;
}

//求最大公约数
int _gcd(int a, int b) {
    int gcd;
    if (a &gt; b)
        gcd = b;
    else
        gcd = a;
    while (a % gcd || b % gcd)
        gcd--;
    return gcd;
}

int main(void) {
    int x, y;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    printf(&quot;最小公倍数：%d\n&quot;, _lcm(x, y));
    printf(&quot;最大公约数：%d\n&quot;, _gcd(x, y));
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入两个数：16 72
最小公倍数：144
最大公约数：8
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>实例中用到了辗转相除法来求最大公约数。在求最小公倍数时要清楚最大公约数和最小公倍数的关系，即两数相乘的积除以这两个数的最大公约数就是最小公倍数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：15、水仙花数，阿姆斯特朗数]]></title>
        <id>https://acoldfront.github.io/post/c-example15/</id>
        <link href="https://acoldfront.github.io/post/c-example15/">
        </link>
        <updated>2020-05-06T03:49:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>阿姆斯特朗数也就是俗称的水仙花数，是指一个三位数，其各位数字的立方和等于该数本身。例如：153=13+53+33，所以 153 就是一个水仙花数。求出所有的水仙花数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>阿姆斯特朗数也就是俗称的水仙花数，是指一个三位数，其各位数字的立方和等于该数本身。例如：153=13+53+33，所以 153 就是一个水仙花数。求出所有的水仙花数。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
对于阿姆斯特朗数问题，根据水仙花数的定义，需要分离出个位数、十位数和百位数。然后按其性质进行计算并判断，满足条件则打印输出，否则不打印输出。</p>
<p>因此，阿姆斯特朗数问题可以利用循环语句解决。设循环变量为 i，初值为 100，i 从 100 变化到 1000；依次判断条件是否成立，如果成立则输出，否则不输出。</p>
<p>算法思想具体如下：<br>
① 分离出个位数，算术表达式为：j=i%10。<br>
② 分离出十位数，算术表达式为：k=i/10%10。<br>
③ 分离出百位数，算术表达式为：n=i/100。<br>
④ 判断条件是否成立。若是，执行步骤 ⑤；若不是，执行步骤 ⑥。<br>
⑤ 打印输出结果。<br>
⑥ i 自增 1。<br>
⑦ 转到 ① 执行，直到 i 等于 1000。</p>
<p>其判断的条件为：j<em>j</em>j+k<em>k</em>k+n<em>n</em>n==i。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, k, n;
    for (n = 100; n &lt; 1000; ++n) {
        i = n / 100;  //分解出百位
        j = n / 10 % 10;    //分解出十位
        k = n % 10; //分解出个位
        if (i*i*i+j*j*j+k*k*k == n)
            printf(&quot;水仙花数是:%-5d\n&quot;,n);
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>水仙花数是:153
水仙花数是:370
水仙花数是:371
水仙花数是:407
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>实训中需注意的是在分离个位数、十位数和百位数时，算术运算符的选择。要清楚每一种算术运算符的运算规则和结合性，再根据题意选择合适的算术运算符进行运算。在本实例中使用了除法运算符“/”和求余运算符（模运算符）“％”。</p>
<p>在程序中由于循环体的语句不止一句，因此我们在使用时必须用“{}”括起来，组成复合语句进行使用。在程序中应把复合语句看成是单条语句而不是多条语句，复合语句内的各条语句都必须以分号“;”结尾；此外，在括号“}”外不能加分号。一般复合语句用于要执行某段特殊功能的程序如 for 语句、if 语句或 while 语句等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：14、判断三角形的类型]]></title>
        <id>https://acoldfront.github.io/post/c-example14/</id>
        <link href="https://acoldfront.github.io/post/c-example14/">
        </link>
        <updated>2020-05-06T03:28:27.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>根据输入的三角形的三条边判断三角形的类型，并输出其面积和类型。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>根据输入的三角形的三条边判断三角形的类型，并输出其面积和类型。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先判断其两边之和是否大于第三边，若大于则判断可以构成三角形，再进一步判断该三角形是什么三角形，并计算这个三角形的面积；否则不能构成三角形。</p>
<p>① 从键盘输入三角形的三条边。</p>
<p>② 判断两边之和是否大于第三边。</p>
<p>③ 若条件成立则判断可构成三角形，计算其面积，并判断其类型；否则判断其不能构成三角形。</p>
<p>④ 在类型判断中首先判断其是否三边相等，条件成立则判断其为等边三角形；否则判断其是否有两边相等，条件成立则判断其为等腰三角形；否则判断其是否有两边的平方和等于第三边的平方，条件成立则判断其为直角三角形；否则判断其为普通三角形。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    float a, b, c;
    float s, area;
    printf(&quot;请输入三角形的三条边:\n&quot;);
    scanf(&quot;%f,%f,%f&quot;, &amp;a, &amp;b, &amp;c);
    if (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; b) {   //两边之和大于第三边
        s = (a + b + c) / 2;
        area = (float) sqrt(s * (s - a) * (s - b) * (s - c));   //（海伦公式）（p=(a+b+c)/2）
        printf(&quot;三角形的面积是：%f\n&quot;, area);
        if (a == b &amp;&amp; a == c) {
            printf(&quot;三角形是等边三角形\n&quot;);
        } else if (a == b || b == c || a == c) {
            printf(&quot;三角形是等腰三角形\n&quot;);
        } else if ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a * a))
            printf(&quot;三角形是直角三角形\n&quot;);
        else
            printf(&quot;三角形是普通三角形\n&quot;);
    } else
        printf(&quot;不能构成三角形\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入三角形的三条边:
3,3,3
三角形的面积是：3.897114
三角形是等边三角形
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 在本实训之前必须知道三角形的相关知识，比如，怎么判断输入的三边是否能构成三角形、三角形的面积计算方法等。</p>
<p>② 要注意逻辑运算符“&amp;&amp;”和“||”的使用，当需要同时满足多个条件时，使用“&amp;&amp;”运算符；而当只需满足多个条件中的一个时，使用“||”运算符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：13、求n的阶乘（n!）]]></title>
        <id>https://acoldfront.github.io/post/c-example13/</id>
        <link href="https://acoldfront.github.io/post/c-example13/">
        </link>
        <updated>2020-05-06T03:20:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先要清楚阶乘定义，所谓 n 的阶乘，就是从 1 开始乘以比前一个数大 1 的数，一直乘到 n，用公式表示就是：1×2×3×4×…×(n-2)×(n-1)×n=n!</p>
<p>具体的操作:利用循环解决问题，设循环变量为 i，初值为 1，i 从 1 变化到 n；依次让 i 与 sum 相乘，并将乘积赋给 sum。<br>
① 定义变量 sum，并赋初值 1。<br>
② i 自增 1。<br>
③ 直到 i 超过 n。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, n;
    double sum = 1,sum1=1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法一；
    for (i = 1; i &lt;= n; ++i) {
        sum *= i;
    }
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<hr>
<h3 id="方法二">方法二：</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//使用递归
double f(int n) {
    if (n == 1)
        return 1;
    else
        return n * f(n - 1);
}
int main(void) {
    int i, n;
    double sum = 1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法二：
    sum = f(n);//使用递归
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 由于阶乘一般较大，会超出整型甚至是长整型所能表示的范围，因此定义变量时就不能定义为整型，而应该考虑双精度数。</p>
<p>② 实训中定义了一个双精度型的变量，用来存放结果。因此在输出时应注意双精度数的输出格式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
<p><strong>实现过程：</strong><br>
(1)定义结构体 index，用于存储块的结构，并定义该结构体数组 index_table。</p>
<p>(2)自定义函数 block_search()，实现分块查找。</p>
<p>(3) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct index    //定义块的结构
{
    int key;    //块的关键字
    int start;    //块的起始值
    int end;    //块的结束值
} index_table[4];    //定义结构体数组

int block_search(int key, int a[])    //自定义实现分块查找
{
    int i, j;
    i = 1;
    while (i &lt;= 3 &amp;&amp; key &gt; index_table[i].key)    //确定在哪个块中
        i++;
    if (i &gt; 3)    //大于分得的块数，则返回0
        return 0;
    j = index_table[i].start;    //j等于块范围的起始值
    while (j &lt;= index_table[i].end &amp;&amp; a[j] != key)    //在确定的块内进行顺序查找
        j++;
    if (j &gt; index_table[i].end)    //如果大于块范围的结束值，则说明没有要査找的数，j置0
        j = 0;
    return j;
}

int main() {
    int i, j = 0, k, key, a[16];
    printf(&quot;请输入15个数：\n&quot;);
    for (i = 1; i &lt; 16; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //输入由小到大的15个数
    for (i = 1; i &lt;= 3; i++) {
        index_table[i].start = j + 1;    //确定每个块范围的起始值
        j = j + 1;
        index_table[i].end = j + 4;    //确定每个块范围的结束值
        j = j + 4;
        index_table[i].key = a[j];    //确定每个块范围中元素的最大值
    }
    printf(&quot;请输入你想査找的元素：\n&quot;);
    scanf(&quot;%d&quot;, &amp;key);    //输入要查询的数值
    k = block_search(key, a);    //调用函数进行杳找
    if (k != 0)
        printf(&quot;查找成功，其位置是：%d\n&quot;, k);    //如果找到该数，则输出其位置
    else
        printf(&quot;查找失败!&quot;);    //若未找到，则输出提示信息
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入15个数：
11 12 18 28 39 56 69 89 96 122 135 146 156 256 298
请输入你想査找的元素：
96
查找成功，其位置是：9
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>分块査找也称为索引顺序査找，要求将待查的元素均匀地分成块，块间按大小排序，块内不排序，所以要建立一个块的最大（或最小）关键字表，称为索引表。</p>
<p>本实例中将给出的 15 个数按关键字大小分成了 3 块，这 15 个数的排列是一个有序序列，也可以给出无序序列，但必须满足分在第一块中的任意数都小于第二块中的所有数，第二块中的所有数都小于第三块中的所有数。当要査找关键字为 key 的元素时，先用顺序杳找在已建好的索引表中查出 key 所在的块中，再在对应的块中顺序查找 key，若 key 存在，则输出其相应位置，否则输出提示信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：11、二分查找算法，折半查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example11/</id>
        <link href="https://acoldfront.github.io/post/c-example11/">
        </link>
        <updated>2020-05-05T13:11:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>折半查找法也叫做二分查找，顾名思义，就是把数据分成两半，再判断所查找的key在哪一半中，再重复上述步骤知道找到目标key;<br>
<strong>注意：（咳咳，敲黑板）折半查找法仅适用于对已有顺序的数组、数据进行操作！！！</strong></p>
<p>折半查找只能在有序数列中进行，将待查找的数据与有序数列（递增）中间的元素进行比较，如果相等，则找到；如果待查找的数据大于中间的元素的值，那么再从数组的后一半元素中进行查找，否则，从前一半元素中进行查找；若折半后都找不到，则输出“没找着”等提示信息。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：要在数组arr[]={8,7,9,6,4,1,2,5,3,10,11};中查找key=7的位置；首先，我们要先将数组arr中的数据成员进行排序。arr[]={1,2,3,4,5,6,7,8,9,10,11};<br>
<img src="https://acoldfront.github.io//post-images/1588696496749.png" alt="" loading="lazy"><br>
如图所示：将该组数据小端记作low，大端记作high,中间值记作mid;<br>
二分法查找时，将所查找的key与mid比较，例如key=7，即可缩小查找范围在mid和high之间；<br>
<img src="https://acoldfront.github.io//post-images/1588696476328.png" alt="" loading="lazy"><br>
如图所示即可找到key=low=7;<br>
<strong>注意：（敲黑板）如果中间数mid不是整数，需要进行取整。</strong></p>
<p><strong>实现过程：</strong><br>
(1) 自定义函数 binary_search()，实现二分査找。</p>
<p>(2) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int binary_search(int key, int a[], int n) { //自定义函数binary_search()

    int low, high, mid, count = 0, count1 = 0;
    low = 0;
    high = n - 1;
    while (low &lt; high)    //査找范围不为0时执行循环体语句
    {
        count++;    //count记录査找次数
        mid = (low + high) / 2;    //求中间位置
        if (key &lt; a[mid])    //key小于中间值时
            high = mid - 1;    //确定左子表范围
        else if (key &gt; a[mid])    //key 大于中间值时
            low = mid + 1;    //确定右子表范围
        else if (key == a[mid])    //当key等于中间值时，证明查找成功
        {
            printf(&quot;查找成功!\n 查找 %d 次!a[%d]=%d&quot;, count, mid, key);    //输出査找次数及所査找元素在数组中的位置
            count1++;    //count1记录查找成功次数
            break;
        }
    }
    if (count1 == 0)    //判断是否查找失敗
        printf(&quot;查找失敗!&quot;);    //査找失敗输出no found
    return 0;
}

int main() {
    int i, key, a[100], n;
    printf(&quot;请输入数组的长度：\n&quot;);
    scanf(&quot;%d&quot;, &amp;n);    //输入数组元素个数
    printf(&quot;请输入数组元素：\n&quot;);
    for (i = 0; i &lt; n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //输入有序数列到数组a中
    printf(&quot;请输入你想查找的元素：\n&quot;);
    scanf(&quot;%d&quot;, &amp;key);    //输入要^找的关键字
    binary_search(key, a, n);    //调用自定义函数
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数组的长度：
10
请输入数组元素：
2   3   5   6   8   10  12  13  15  18
请输入你想查找的元素：
8
查找成功!
 查找 1 次!a[4]=8
</code></pre>
<hr>
<p><strong>方法二：</strong></p>
<pre><code class="language-c">int BinSearch(int arr[], int len, int key) {                         //折半查找法（二分法）
    int low = 0;                         //定义初始最小
    int high = len - 1;                 //定义初始最大
    int mid;                            //定义中间值
    while (low &lt;= high) {
        mid = (low + high) / 2;              //找中间值
        if (key == arr[mid])               //判断min与key是否相等
            return mid;
        else if (key &gt; arr[mid])             //如果key&gt;mid  则新区间为[mid+1,high]
            low = mid + 1;
        else                                       //如果key&lt;mid  则新区间为[low,mid-1]
            high = mid - 1;
    }
    return -1;                             //如果数组中无目标值key，则返回 -1 ；
}

void main() {
    int a[] = {2, 3, 5, 6, 8, 10, 12, 13, 15, 18};//二分搜索是已排好序
    int i, n, addr;
    printf(&quot;the array is:\n&quot;);
    for (i = 0; i &lt; sizeof(a) / sizeof(int); i++)
        printf(&quot;%-4d&quot;, a[i]);
    printf(&quot;\nsearch number is:&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    addr = BinSearch(a, sizeof(a) / sizeof(int), n);
    if (-1 == addr)
        printf(&quot;can't find!\n&quot;);
    else
        printf(&quot;the %d is %dth at the array.\n&quot;, n, addr);
}
</code></pre>
<p>输出结果：</p>
<pre><code>the array is:
2   3   5   6   8   10  12  13  15  18
search number is:8
the 8 is 4th at the array.
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>·二分査找就是折半查找，其基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）。</p>
]]></content>
    </entry>
</feed>