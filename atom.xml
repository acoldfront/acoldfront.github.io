<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-05T15:03:40.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：11、二分查找算法，折半查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example11/</id>
        <link href="https://acoldfront.github.io/post/c-example11/">
        </link>
        <updated>2020-05-05T13:11:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：10、归并排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example10/</id>
        <link href="https://acoldfront.github.io/post/c-example10/">
        </link>
        <updated>2020-05-05T13:10:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：9、选择排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example9/</id>
        <link href="https://acoldfront.github.io/post/c-example9/">
        </link>
        <updated>2020-05-05T13:10:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：8、快速排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example8/</id>
        <link href="https://acoldfront.github.io/post/c-example8/">
        </link>
        <updated>2020-05-05T13:09:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：7、直接插入排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example7/</id>
        <link href="https://acoldfront.github.io/post/c-example7/">
        </link>
        <updated>2020-05-05T13:09:08.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>直接插入排序的基本原理就如同打扑克牌一样，起初在摸牌的时候，第一张牌对于自身而言是有序的，假如摸到4，当第二次摸到6时，会将6放在4的后面，第三次摸到3时，会将3放在4的前面，这个过程就是直接插入排序。那么对于6和3而言，如何知道是大还是小呢？过程很简单，每摸到一张牌就和前面已有序数列作比较比较，然后交换顺序即可。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如:8、45、18、33、15、99、3<br>
说明：按照从小到大的顺序进行排序。</p>
<p>具体实现步骤如下：设置一个临时变量temp，其值为当前所摸牌的值，然后和它的前一张牌（即已有序列的最后一张牌）开始比较，如果temp小于前一张牌的值，就把前一张牌放在当前位置，结果比较有序序列的倒数第二位置，如果再小，重复上述步骤，如果大于，由于比较的是有序序列，故此是为有序状态，最后把temp的值放在和有序序列中最后一个比较的值的下一位置当有序之后，退出循环。具体可根据下述图进行自行分析。<br>
备注：</p>
<ul>
<li>其中i表示当前所摸的牌，j表示已有序数列的最后一张牌，从后往前比较。</li>
<li>其中蓝色空格为temp的值,不代表方框中的值,彩色线条为两数之间的比较。</li>
<li>以下每一步均为比较完变化后的结果。<br>
(1)第一趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689732582.png" alt="" loading="lazy"><br>
(2)第二趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588690023139.png" alt="" loading="lazy"><br>
以此类推...<br>
(3)第六趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689972515.png" alt="" loading="lazy"><br>
此时待排序列已全部有序。<br>
拓展：n个数排序需要n - 1躺。</li>
</ul>
<p><strong>实现过程：</strong><br>
(1) 自定义一个函数，实现直接插入排序，在本实例中，我们自定义该函数为 insort()。</p>
<p>(2) main() 函数为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int insort(int s[], int n) {    //自定义函数 insort()
    int i, j, temp;
    for (i = 1; i &lt; n; ++i) {   //由于temp的初值为第二个数，故i为1
        temp = s[i];
        for (j = i - 1; j &gt;= 0; j--) {
            if (s[j] &gt; temp) {
                s[j + 1] = s[j];
            } else {
                break;
            }
        }
        s[j + 1] = temp;
    }
    return 0;
}

int main(void) {
    int a[10], i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    insort(a, 10);
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        printf(&quot;%5d&quot;, a[i]);    //将排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
25 12 36 45 2 9 39 22 98 37
排序后的顺序是：
    2    9   12   22   25   36   37   39   45   98
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>直接插入排序是将一个数与一组已排号顺序的序列中的最后一个数进行比较。直接插入排序是一种稳定的排序算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：6、冒泡排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example6/</id>
        <link href="https://acoldfront.github.io/post/c-example6/">
        </link>
        <updated>2020-05-05T04:19:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>冒泡排序是一种较为简单的排序算法，其基本思想为从头开始依次比较相邻的两个元素大小，将较大（较小）的元素移至右端，最终使最大（最小）的元素移至序列最后，再次重复上述过程，直到最终序列完全有序为止。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：有一行数分别是26、10，83，56，28，66，7<br>
说明：按照从小到大的顺序进行排序，方框数为比较的次数，以下图示为比较完交换的结果。</p>
<p>(1)第一躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688650202.png" alt="" loading="lazy"><br>
此时已将此行数中最大的那个数字放在末尾。<br>
(2)第二躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688660796.png" alt="" loading="lazy"><br>
此时将倒数第二大的数字放在后面。<br>
(3)第三趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688685619.png" alt="" loading="lazy"><br>
此时将倒数第三大的数字放在后面。<br>
以此类推，可以得到最终结果为：7、10、26、28、56、66、83。<br>
备注：n个数要比较n - 1趟，第一躺比较n - 1次，第 j 趟需要比较n - j 次。</p>
<p><strong>实现过程：</strong><br>
(1) 通过两个 for 循环实现冒泡排序的全过程，外层 for 循环决定冒泡排序的趟数，内层 for 循环决定每趟所进行两两比较的次数。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, tmp, a[10];    //定义变量及数组为基本整型
    printf(&quot;请输入10个数：\n&quot;);
    for (int i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    for (i = 1; i &lt; 10; ++i) {  //变量i代表比较的趟数
        for (j = 0; j &lt; 10 - i; ++j) {  //变最j代表每趟两两比较的次数
            if (a[j] &gt; a[j + 1]) {
                tmp = a[j]; //产利用中间变童实现两值互换
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }

    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //将冒泡排序后的顺序输出
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<hr>
<p><strong>改进版冒泡排序：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    //改进版冒泡排序
    int x, y, flag, tmp1, b[10];
    printf(&quot;请输入10个数：\n&quot;);
    for (int x = 0; x &lt; 10; ++x) {
        scanf(&quot;%d&quot;, &amp;b[x]);//从键盘中输入10个数
    }
    for (x = 1; x &lt; 10; ++x) {
        flag = 0;       //假设第x行没有交换数据，flag=0
        for (y = 0; y &lt; 10 - x; ++y) {
            if (b[y] &gt; b[y + 1]) {
                tmp1 = b[y];
                b[y] = b[y + 1];
                b[y + 1] = tmp1;
                flag = 1;   //交换数据，flag=1
            }
        }
        if (0 == flag) {    //若flag=0，表明第x行没有交换数据
            break;
        }
    }
    printf(&quot;排序后的顺序是：\n&quot;);
    for (x = 0; x &lt; 10; x++) {
        printf(&quot;%5d&quot;, b[x]);    //将冒泡排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例要求用冒泡法对 10 个数由小到大进行排序，冒泡法的基本思路是，如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第 1 趟比较中要进行 n-j 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较。从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：5、希尔排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example5/</id>
        <link href="https://acoldfront.github.io/post/c-example5/">
        </link>
        <updated>2020-05-05T04:11:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)自定义函数 shsort()，实现希尔排序。</p>
<p>(2) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int shsort(int s[], int n) {
    int i, j, d;
    d = n / 2;    //确定固定增虽值
    while (d &gt;= 1) {
        for (i = d + 1; i &lt;= n; ++i) {    //数组下标从d+1开始进行直接插入排序
            s[0] = s[i];  //设置监视哨
            j = i - d;  //确定要进行比较的元素的最右边位置
            while ((j &gt; 0) &amp;&amp; (s[0] &lt; s[j])) {
                s[j + d] = s[j];    //数据右移
                j = j - d;  //向左移d个位置
            }
            s[j + d] = s[0];    //在确定的位罝插入s[i]
        }
        d = d / 2;    //增里变为原来的一半
    }
    return 0;
}

int main(void) {
    int a[11], i;    //定义数组及变量为基本整型
    printf(&quot;请输入 10 个数据：\n&quot;);
    for (i = 1; i &lt;= 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);  //从键盘中输入10个数据
    }
    shsort(a, 10);    //调用 shsort()函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数组
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入 10 个数据：
69 56 12 136 3 55 46 99 88 25
排序后的顺序是：
    3   12   25   46   55   56   69   88   99  136
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>希尔排序是在直接插入排序的基础上做的改进，也就是将寒排序的序列按固定增量分成若干组，等距者在同二组中，然后再在组内进行直接插入排序。这里面的固定增量从 n/2 开始，以后每次缩小到原来的一半。<br>
<a href="https://blog.csdn.net/weixin_37818081/article/details/79202115">不懂希尔排序原理可以看</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：4、渔夫打鱼晒网]]></title>
        <id>https://acoldfront.github.io/post/c-example4/</id>
        <link href="https://acoldfront.github.io/post/c-example4/">
        </link>
        <updated>2020-05-05T03:58:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 自定义函数 leap()，用来判断输入的年份是否是闰年。</p>
<p>(2) 自定义函数 number()，用来计算输入日期距 2011 年 1 月 1 日共有多少天。</p>
<p>(3) main() 函数作为程序的入口函数，在 main() 函数中调用上面两个函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int leap(int a) {   //自定义函数leap()用来指定输入的年份是否为闰年
    if (a % 4 == 0 &amp;&amp; a % 100 != 0 || a % 400 == 0)    //闰年判定条件
        return 1;   //是闰年返回1
    else
        return 0;   //不是闰年返回O
}

int number(int year, int month, int day) {    //自定义函数 number() 计算输入日期距2011年1月1日共有多少天
    int sum = 0, i, j, k;
    int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组a存放平年每月的天数
    int b[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组b存放闰年每月的天数
    if (leap(year) == 1) {    //判断是否为闰年
        for (i = 0; i &lt; month - 1; ++i)
            sum += b[i];    //是闰年，累加数组b前m-1个月份的天数
    } else {
        for (i = 0; i &lt; month - 1; ++i)
            sum += a[i];    //不是闰年，累加数组a前m-1个月份的天数
    }
    for (j = 2011; j &lt; year; ++j) {
        if (leap(j) == 1)
            sum += 366;   //2011年到输入的年份是闰年的加366
        else
            sum += 365;   //2011年到输入的年份不是闰年的加365
    }
    sum += day;    //将前面累加的结果加上日期，求出总天数
    return sum; //返回计算的天数
}

int main(void) {
    int year, month, day, n;
    printf(&quot;请输入年月日\n&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;year, &amp;month, &amp;day);    //输入年月日
    n = number(year, month, day);
    if ((n % 5) &lt; 4 &amp;&amp; (n % 5) &gt; 0)    //余数是1或2或3时说明在打渔，否则在晒网
        printf(&quot;%d：%d：%d 打鱼\n&quot;, year, month, day);
    else
        printf(&quot;%d：%d：%d 晒网\n&quot;, year, month, day);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入年月日
2011 1 4
2011：1：4 晒网
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例主要有以下两个技术要点：</p>
<p>(1) 判断输入的年份（2011 年以后包括 2011 年）是否为闰年，这里自定义函数 leap() 来进行判断。该函数的核心内容就是闰年的判断条件即能被 4 整除但不能被 100 整除，或能被 400 整除。</p>
<p>(2) 求输入日期距 2011 年 1 月 1 日有多少天。首先判断 2011 年距输入的年份有多少年，这其中有多少年是闰年就将 sum 加多少个 366，有多少年是平年便将 sum 加上多少个 365。</p>
<p>其次要将 12 个月每月的天数存到数组中，因为闰年 2 月份的天数有别于平年，故采用两个数组 a 和 b 分别存储。若输入年份是平年，月份为 m 时就在前面累加日期的基础上继续累加存储着平年每月天数的数组的前 m-1 个元素，将累加结果加上输入的日期便求出了最终结果。闰年的算法类似。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：3、百元买鸡]]></title>
        <id>https://acoldfront.github.io/post/c-example3/</id>
        <link href="https://acoldfront.github.io/post/c-example3/">
        </link>
        <updated>2020-05-05T03:39:52.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)使用 for 语句对 3 种鸡的数嫌在事先确定好的范围内进行穷举并判断，对满足条件的 3 种鸡的数量按指定格式输出，否则进行下次循环。</p>
<p>(2) 程序的代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
   int cook, hen, chick;   //定义变童为基本整型

    for (cook = 0; cook &lt;= 100; ++cook) {
        for (hen = 0; hen &lt;= 100; ++hen) {
            for (chick = 0; chick &lt;= 100; ++chick) {
                if ((5 * cook + 3 * hen + chick / 3) == 100 &amp;&amp; chick % 3 == 0 &amp;&amp; cook+hen+chick==100)
                    //(5 * cook + 3 * hen + chick / 3) == 100   判断钱数是否等于 100
                    //chick % 3 == 0    判断小鸡数是否能被 3 整除
                    //cook+hen+chick==100  判断购买的鸡数是否等于 100
                    printf(&quot;公鸡 %2d 只，母鸡 %2d 只，小鸡 %2d 只\n&quot;, cook, hen, chick);
            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>公鸡  0 只，母鸡 25 只，小鸡 75 只
公鸡  4 只，母鸡 18 只，小鸡 78 只
公鸡  8 只，母鸡 11 只，小鸡 81 只
公鸡 12 只，母鸡  4 只，小鸡 84 只
</code></pre>
<p>###技术要点： ###<br>
根据题意设公鸡、母鸡和雏鸡分别为 cock、hen 和 chick，如果 100 元全买公鸡，那么最多能买 20 只，所以 cock 的范围是大于等于 0 且小于等于 20；如果全买母鸡，那么最多能买 33 只，所以 hen 的范围是大于等于 0 且小于等于 33；如果 100 元钱全买小鸡，那么最多能买 99 只（根据题意小鸡的数量应小于 100 且是 3 的倍数）。</p>
<p>在确定了各种鸡的范围后进行穷举并判断，判断的条件有以下 3 点：<br>
(1) 所买的 3 种鸡的钱数总和为 100。<br>
(2) 所买的 3 种鸡的数量之和为 100。<br>
(3) 所买的小鸡数必须是 3 的倍数。</p>
]]></content>
    </entry>
</feed>