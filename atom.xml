<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-08T04:47:52.898Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：21、斐波那契、兔子生兔子]]></title>
        <id>https://acoldfront.github.io/post/c-example21/</id>
        <link href="https://acoldfront.github.io/post/c-example21/">
        </link>
        <updated>2020-05-08T04:15:22.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。<br>
假设一对兔子的成熟期是一个月，即一个月可长成成兔，那么，如果每对成兔每个月都生一对小兔，一对新生的小兔从第二个月起就开始生兔子，试问从一对兔子开始繁殖，以后每个月会有多少对兔子？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。<br>
假设一对兔子的成熟期是一个月，即一个月可长成成兔，那么，如果每对成兔每个月都生一对小兔，一对新生的小兔从第二个月起就开始生兔子，试问从一对兔子开始繁殖，以后每个月会有多少对兔子？</p>
</blockquote>
<!-- more -->
<pre><code class="language-c">#include &lt;stdio.h&gt;

//斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。

int main(void) {
    int n = 0;
    printf(&quot;请输入一个数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);

    //若要打印 斐波那契数列
    int f1 = 1, f2 = 1, f3, i;
    printf(&quot;%8d%8d&quot;, f1, f2);
    for (i = 3; i &lt;= n; i++) {
        f3 = f1 + f2;
        printf(&quot;%8d&quot;, f3);
        f1 = f2;
        f2 = f3;
    }
    return 0;
}



</code></pre>
<p>输出结果：</p>
<pre><code>请输入一个数：5
       1       1       2       3       5
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>(1) 实例分析<br>
循环的嵌套是指在一个循环体内又包含了另一个完整的循环。循环的嵌套执行过程是外循环执行一次，内循环执行一次，在内循环结束后，再执行下一次外循环，如此反复，直到外循环结束。</p>
<p>(2) 循环的嵌套注意事项：<br>
① 循环必须完全包含内循环，不能交叉；<br>
② 在多重循环中，各层循环的循环控制变量不能同名；<br>
③ 在多重循环中，并列循环的循环控制变量名可以相同，也可以不同。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：20、判断闰年，即判断年份是否为闰年]]></title>
        <id>https://acoldfront.github.io/post/c-example20/</id>
        <link href="https://acoldfront.github.io/post/c-example20/">
        </link>
        <updated>2020-05-06T09:49:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
判断任意年份是否为闰年，需要满足以下条件中的任意一个：<br>
① 该年份能被 4 整除同时不能被 100 整除；<br>
② 该年份能被400整除。</p>
<p>本实例中使用嵌入式 if-else 语句。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int year, a;
    printf(&quot;请输人年份：&quot;);
    scanf(&quot;%d&quot;, &amp;year);
    if (((year % 4 == 0 )&amp;&amp; (year % 100 != 0)) || (year % 400 == 0))
        printf(&quot;%d 此年是闰年\n&quot;, year);
    else
        printf(&quot;%d 此年非闰年\n&quot;,year);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输人年份：1995
1995 此年非闰年

请输人年份：1996
1996 此年是闰年
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：19、求回文数、回文素数]]></title>
        <id>https://acoldfront.github.io/post/c-example19/</id>
        <link href="https://acoldfront.github.io/post/c-example19/">
        </link>
        <updated>2020-05-06T08:58:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
① 获取一个数，例如123<br>
② 求出321与123相比<br>
③ 求123中的个位数：3 -&gt; 123%10/1<br>
十位数：2 -&gt; 123%100/10<br>
百位数：1 -&gt; 123%1000/100<br>
通式：num  %(10*i)/i<br>
④将321 = 3 * 100 +2  * 10 + 1<br>
⑤定义一个snum用来存储倒置的数，即3snum = 21，snum = num % (10 * i) / i + 10 * snum;<br>
第一次循环：s = 3 + 0<br>
第二次循环：s = 2 + 30<br>
第三次循环：s = 1 + 320<br>
⑥对比num 和 snum的值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, num;
    int snum = 0;   //用来存放倒置的数
    intf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;num);
    for (i = 1; i &lt; num; i *= 10) {   //i每次增加10倍，实现个位，十位，百位。。。的转化换
        snum = num % (10 * i) / i + 10*snum;
        //s = 3 + 0
        //s = 2 + 30
        //s = 1 + 320
    }
    if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入一个整数：121
这个数是一个回文数
</code></pre>
<hr>
<blockquote>
<p>求 1000 以内的所有回文素数。</p>
</blockquote>
<p><strong>算法思想：</strong><br>
实例的重点是判断一个数是否是回文素数。要输出 1000 以内的所有回文素数，首先应判断这个数是否是素数；如果是，再进一步判断这个数是两位数还是三位数，若是两位数，则需判断个位数和十位数是否相同；若是三位数，则需判断个位数和百位数是否相同。若相同，则判断为回文素数，否则继续下次判断。</p>
<p>① 定义一个函数 sushu，其作用是判断一个数是否是素数。<br>
② 对判断为素数的数，再判断其是否是两位数。<br>
若是两位数，再判断其个位数和十位数是否相同，若相同则打印输出；若不相同，则执行④；若不是两位数，则执行③。<br>
③ 若是三位数，则判断其个位数和百位数是否相同。若相同，则打印输出；若不相同，则执行 ④。<br>
④ 循环控制变量 i 自增 1。<br>
⑤ 直到 i 自增至 1000 结束。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;stdio.h&gt;

/*判断参数n是否为素数*/
int fun(int n) {
    int i;
    for (i = 2; i &lt; (n - 1) / 2; ++i) {
        if (n % i == 0)
            return 0;
    }
    return 1;
}

int main(void) {
    int i;
    for (i = 10; i &lt; 1000; ++i) {   //10以内没有回文素数
        if (fun(i) == 1) {      //素数
            if (i / 100 == 0) {     //100以内的
                if (i / 10 == i % 10)   //对比十位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);
            } else {
                if (i / 100 == i % 10)  //对比百位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);

            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>   11  101  131  151  181  191  313  353  373  383  727  757  787  797  919  929
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 程序由 main() 函数和 sushu() 函数组成，main() 函数调用 sushu() 函数，整型变量 i 为函数参数。当 sushu () 执行完后，返回到主函数中继续执行被调函数后面的语句。</p>
<p>② 函数调用语句由函数名、实际参数加上分号“;”组成。其一般形式为“函数名(实际参数表);”。执行函数语句就是调用函数体并把实际参数赋予函数定义中的形式参数，然后执行被调函数体中的语句，求取函数值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：18、小写字母转换成大写字母]]></title>
        <id>https://acoldfront.github.io/post/c-example18/</id>
        <link href="https://acoldfront.github.io/post/c-example18/">
        </link>
        <updated>2020-05-06T08:56:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
由于大写字母与小写字母之间的差值为 32，因此小写字母转换为大写字母的方法就是将小写字母的 ASCII 码值减去 32，便可得到与之对应的大写字母。</p>
<p>利用 getchar 函数从键盘上输入一个小写字母，并将其赋给一个字符变量 a；然后将 a—32 的值赋给字符变量 b；最后进行输出，输出时先输出字母，再将字母以整数形式输出。其具体步骤如下：</p>
<p>① 定义两个字符变量 a、b；<br>
② a=get char()；<br>
③ b=a—32；<br>
④ 打印输出。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    char a, b;
    printf(&quot;输入一个小写字母:\n&quot;);
    a = getchar();
    b = a - 32;
    printf(&quot;转换后的字母为：%c，%d\n&quot;, b, b);
    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>输入一个小写字母:
c
转换后的字母为：C，67
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 实例内容要求对 ASCII 码有所了解。知道小写字母和大写字母之间的差值为 32。</p>
<p>② getchar 函数的功能是从键盘上输入一个字符。其一般形式为“getchar()”。通常把输入的字符赋予一个字符变量，构成赋值语句，如：char c;或c=getchar();</p>
<p>③ 使用 getchar 函数还应注意几个问题：<br>
getchar 函数只能接收单个字符，输入数字也按字符处理。输入多于一个字符时，只接收第一个字符。<br>
使用 getchar 函数前必须包含文件“stdio.h”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：17、求自然底数e]]></title>
        <id>https://acoldfront.github.io/post/c-example17/</id>
        <link href="https://acoldfront.github.io/post/c-example17/">
        </link>
        <updated>2020-05-06T04:16:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>自然底数 e=2.718281828…，e 的计算公式如下：<br>
e=1+1/1!+1/2!+1/3!+…<br>
要求当最后一项的值小于 10-10 时结束。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>自然底数 e=2.718281828…，e 的计算公式如下：<br>
e=1+1/1!+1/2!+1/3!+…<br>
要求当最后一项的值小于 10-10 时结束。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
使用循环实现累加求和，并在求和后计算下一项所对应的阶乘。</p>
<p>① 用循环语句 while 进行循环控制。判断条件为 1/n&gt;10-10；条件成立则执行 ②，条件不成立执行 ⑤；<br>
② 计算求和 e+=1/n；<br>
③ i 自增 1；<br>
④ 计算下一项所对应的阶乘：n=i*n；<br>
⑤ 结束循环，打印输出结果。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    float e = 1.0, n = 1.0;
    int i = 1;
    while (1 / n &gt; 1e-10) {
        e += 1 / n;
        i++;
        n = i * n;
    }
    printf(&quot;e的值是：%f\n&quot;,e);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>e的值是：2.718282
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：16、最大公约数和最小公倍数]]></title>
        <id>https://acoldfront.github.io/post/c-example16/</id>
        <link href="https://acoldfront.github.io/post/c-example16/">
        </link>
        <updated>2020-05-06T03:57:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入两个正整数 a 和 b，求其最大公约数和最小公倍数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入两个正整数 a 和 b，求其最大公约数和最小公倍数。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
利用格式输入语句将输入的两个数分别赋给 a 和 b，然后判断 a 和 b 的关系，如果 a 小于 b，则利用中间变量 t 将其互换。再利用辗转相除法求出最大公约数，进而求出最小公倍数。最后用格式输出语句将其输出。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最小公倍数
int _lcm(int a, int b) {
    int lcm;
    if (a &gt; b)
        lcm = a;
    else
        lcm = b;
    while (lcm % a || lcm % b)
        lcm++;
    return lcm;
}

//求最大公约数
int _gcd(int a, int b) {
    int gcd;
    if (a &gt; b)
        gcd = b;
    else
        gcd = a;
    while (a % gcd || b % gcd)
        gcd--;
    return gcd;
}

int main(void) {
    int x, y;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    printf(&quot;最小公倍数：%d\n&quot;, _lcm(x, y));
    printf(&quot;最大公约数：%d\n&quot;, _gcd(x, y));
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入两个数：16 72
最小公倍数：144
最大公约数：8
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>实例中用到了辗转相除法来求最大公约数。在求最小公倍数时要清楚最大公约数和最小公倍数的关系，即两数相乘的积除以这两个数的最大公约数就是最小公倍数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：15、水仙花数，阿姆斯特朗数]]></title>
        <id>https://acoldfront.github.io/post/c-example15/</id>
        <link href="https://acoldfront.github.io/post/c-example15/">
        </link>
        <updated>2020-05-06T03:49:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>阿姆斯特朗数也就是俗称的水仙花数，是指一个三位数，其各位数字的立方和等于该数本身。例如：153=13+53+33，所以 153 就是一个水仙花数。求出所有的水仙花数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>阿姆斯特朗数也就是俗称的水仙花数，是指一个三位数，其各位数字的立方和等于该数本身。例如：153=13+53+33，所以 153 就是一个水仙花数。求出所有的水仙花数。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
对于阿姆斯特朗数问题，根据水仙花数的定义，需要分离出个位数、十位数和百位数。然后按其性质进行计算并判断，满足条件则打印输出，否则不打印输出。</p>
<p>因此，阿姆斯特朗数问题可以利用循环语句解决。设循环变量为 i，初值为 100，i 从 100 变化到 1000；依次判断条件是否成立，如果成立则输出，否则不输出。</p>
<p>算法思想具体如下：<br>
① 分离出个位数，算术表达式为：j=i%10。<br>
② 分离出十位数，算术表达式为：k=i/10%10。<br>
③ 分离出百位数，算术表达式为：n=i/100。<br>
④ 判断条件是否成立。若是，执行步骤 ⑤；若不是，执行步骤 ⑥。<br>
⑤ 打印输出结果。<br>
⑥ i 自增 1。<br>
⑦ 转到 ① 执行，直到 i 等于 1000。</p>
<p>其判断的条件为：j<em>j</em>j+k<em>k</em>k+n<em>n</em>n==i。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, k, n;
    for (n = 100; n &lt; 1000; ++n) {
        i = n / 100;  //分解出百位
        j = n / 10 % 10;    //分解出十位
        k = n % 10; //分解出个位
        if (i*i*i+j*j*j+k*k*k == n)
            printf(&quot;水仙花数是:%-5d\n&quot;,n);
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>水仙花数是:153
水仙花数是:370
水仙花数是:371
水仙花数是:407
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>实训中需注意的是在分离个位数、十位数和百位数时，算术运算符的选择。要清楚每一种算术运算符的运算规则和结合性，再根据题意选择合适的算术运算符进行运算。在本实例中使用了除法运算符“/”和求余运算符（模运算符）“％”。</p>
<p>在程序中由于循环体的语句不止一句，因此我们在使用时必须用“{}”括起来，组成复合语句进行使用。在程序中应把复合语句看成是单条语句而不是多条语句，复合语句内的各条语句都必须以分号“;”结尾；此外，在括号“}”外不能加分号。一般复合语句用于要执行某段特殊功能的程序如 for 语句、if 语句或 while 语句等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：14、判断三角形的类型]]></title>
        <id>https://acoldfront.github.io/post/c-example14/</id>
        <link href="https://acoldfront.github.io/post/c-example14/">
        </link>
        <updated>2020-05-06T03:28:27.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>根据输入的三角形的三条边判断三角形的类型，并输出其面积和类型。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>根据输入的三角形的三条边判断三角形的类型，并输出其面积和类型。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先判断其两边之和是否大于第三边，若大于则判断可以构成三角形，再进一步判断该三角形是什么三角形，并计算这个三角形的面积；否则不能构成三角形。</p>
<p>① 从键盘输入三角形的三条边。</p>
<p>② 判断两边之和是否大于第三边。</p>
<p>③ 若条件成立则判断可构成三角形，计算其面积，并判断其类型；否则判断其不能构成三角形。</p>
<p>④ 在类型判断中首先判断其是否三边相等，条件成立则判断其为等边三角形；否则判断其是否有两边相等，条件成立则判断其为等腰三角形；否则判断其是否有两边的平方和等于第三边的平方，条件成立则判断其为直角三角形；否则判断其为普通三角形。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    float a, b, c;
    float s, area;
    printf(&quot;请输入三角形的三条边:\n&quot;);
    scanf(&quot;%f,%f,%f&quot;, &amp;a, &amp;b, &amp;c);
    if (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; b) {   //两边之和大于第三边
        s = (a + b + c) / 2;
        area = (float) sqrt(s * (s - a) * (s - b) * (s - c));   //（海伦公式）（p=(a+b+c)/2）
        printf(&quot;三角形的面积是：%f\n&quot;, area);
        if (a == b &amp;&amp; a == c) {
            printf(&quot;三角形是等边三角形\n&quot;);
        } else if (a == b || b == c || a == c) {
            printf(&quot;三角形是等腰三角形\n&quot;);
        } else if ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a * a))
            printf(&quot;三角形是直角三角形\n&quot;);
        else
            printf(&quot;三角形是普通三角形\n&quot;);
    } else
        printf(&quot;不能构成三角形\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入三角形的三条边:
3,3,3
三角形的面积是：3.897114
三角形是等边三角形
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 在本实训之前必须知道三角形的相关知识，比如，怎么判断输入的三边是否能构成三角形、三角形的面积计算方法等。</p>
<p>② 要注意逻辑运算符“&amp;&amp;”和“||”的使用，当需要同时满足多个条件时，使用“&amp;&amp;”运算符；而当只需满足多个条件中的一个时，使用“||”运算符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：13、求n的阶乘（n!）]]></title>
        <id>https://acoldfront.github.io/post/c-example13/</id>
        <link href="https://acoldfront.github.io/post/c-example13/">
        </link>
        <updated>2020-05-06T03:20:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先要清楚阶乘定义，所谓 n 的阶乘，就是从 1 开始乘以比前一个数大 1 的数，一直乘到 n，用公式表示就是：1×2×3×4×…×(n-2)×(n-1)×n=n!</p>
<p>具体的操作:利用循环解决问题，设循环变量为 i，初值为 1，i 从 1 变化到 n；依次让 i 与 sum 相乘，并将乘积赋给 sum。<br>
① 定义变量 sum，并赋初值 1。<br>
② i 自增 1。<br>
③ 直到 i 超过 n。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, n;
    double sum = 1,sum1=1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法一；
    for (i = 1; i &lt;= n; ++i) {
        sum *= i;
    }
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<hr>
<h3 id="方法二">方法二：</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//使用递归
double f(int n) {
    if (n == 1)
        return 1;
    else
        return n * f(n - 1);
}
int main(void) {
    int i, n;
    double sum = 1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法二：
    sum = f(n);//使用递归
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 由于阶乘一般较大，会超出整型甚至是长整型所能表示的范围，因此定义变量时就不能定义为整型，而应该考虑双精度数。</p>
<p>② 实训中定义了一个双精度型的变量，用来存放结果。因此在输出时应注意双精度数的输出格式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
<p><strong>实现过程：</strong><br>
(1)定义结构体 index，用于存储块的结构，并定义该结构体数组 index_table。</p>
<p>(2)自定义函数 block_search()，实现分块查找。</p>
<p>(3) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct index    //定义块的结构
{
    int key;    //块的关键字
    int start;    //块的起始值
    int end;    //块的结束值
} index_table[4];    //定义结构体数组

int block_search(int key, int a[])    //自定义实现分块查找
{
    int i, j;
    i = 1;
    while (i &lt;= 3 &amp;&amp; key &gt; index_table[i].key)    //确定在哪个块中
        i++;
    if (i &gt; 3)    //大于分得的块数，则返回0
        return 0;
    j = index_table[i].start;    //j等于块范围的起始值
    while (j &lt;= index_table[i].end &amp;&amp; a[j] != key)    //在确定的块内进行顺序查找
        j++;
    if (j &gt; index_table[i].end)    //如果大于块范围的结束值，则说明没有要査找的数，j置0
        j = 0;
    return j;
}

int main() {
    int i, j = 0, k, key, a[16];
    printf(&quot;请输入15个数：\n&quot;);
    for (i = 1; i &lt; 16; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //输入由小到大的15个数
    for (i = 1; i &lt;= 3; i++) {
        index_table[i].start = j + 1;    //确定每个块范围的起始值
        j = j + 1;
        index_table[i].end = j + 4;    //确定每个块范围的结束值
        j = j + 4;
        index_table[i].key = a[j];    //确定每个块范围中元素的最大值
    }
    printf(&quot;请输入你想査找的元素：\n&quot;);
    scanf(&quot;%d&quot;, &amp;key);    //输入要查询的数值
    k = block_search(key, a);    //调用函数进行杳找
    if (k != 0)
        printf(&quot;查找成功，其位置是：%d\n&quot;, k);    //如果找到该数，则输出其位置
    else
        printf(&quot;查找失败!&quot;);    //若未找到，则输出提示信息
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入15个数：
11 12 18 28 39 56 69 89 96 122 135 146 156 256 298
请输入你想査找的元素：
96
查找成功，其位置是：9
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>分块査找也称为索引顺序査找，要求将待查的元素均匀地分成块，块间按大小排序，块内不排序，所以要建立一个块的最大（或最小）关键字表，称为索引表。</p>
<p>本实例中将给出的 15 个数按关键字大小分成了 3 块，这 15 个数的排列是一个有序序列，也可以给出无序序列，但必须满足分在第一块中的任意数都小于第二块中的所有数，第二块中的所有数都小于第三块中的所有数。当要査找关键字为 key 的元素时，先用顺序杳找在已建好的索引表中查出 key 所在的块中，再在对应的块中顺序查找 key，若 key 存在，则输出其相应位置，否则输出提示信息。</p>
]]></content>
    </entry>
</feed>