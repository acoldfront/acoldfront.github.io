<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-05T04:12:07.865Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：5、希尔排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example5/</id>
        <link href="https://acoldfront.github.io/post/c-example5/">
        </link>
        <updated>2020-05-05T04:11:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：4、渔夫打鱼晒网]]></title>
        <id>https://acoldfront.github.io/post/c-example4/</id>
        <link href="https://acoldfront.github.io/post/c-example4/">
        </link>
        <updated>2020-05-05T03:58:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 自定义函数 leap()，用来判断输入的年份是否是闰年。</p>
<p>(2) 自定义函数 number()，用来计算输入日期距 2011 年 1 月 1 日共有多少天。</p>
<p>(3) main() 函数作为程序的入口函数，在 main() 函数中调用上面两个函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int leap(int a) {   //自定义函数leap()用来指定输入的年份是否为闰年
    if (a % 4 == 0 &amp;&amp; a % 100 != 0 || a % 400 == 0)    //闰年判定条件
        return 1;   //是闰年返回1
    else
        return 0;   //不是闰年返回O
}

int number(int year, int month, int day) {    //自定义函数 number() 计算输入日期距2011年1月1日共有多少天
    int sum = 0, i, j, k;
    int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组a存放平年每月的天数
    int b[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组b存放闰年每月的天数
    if (leap(year) == 1) {    //判断是否为闰年
        for (i = 0; i &lt; month - 1; ++i)
            sum += b[i];    //是闰年，累加数组b前m-1个月份的天数
    } else {
        for (i = 0; i &lt; month - 1; ++i)
            sum += a[i];    //不是闰年，累加数组a前m-1个月份的天数
    }
    for (j = 2011; j &lt; year; ++j) {
        if (leap(j) == 1)
            sum += 366;   //2011年到输入的年份是闰年的加366
        else
            sum += 365;   //2011年到输入的年份不是闰年的加365
    }
    sum += day;    //将前面累加的结果加上日期，求出总天数
    return sum; //返回计算的天数
}

int main(void) {
    int year, month, day, n;
    printf(&quot;请输入年月日\n&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;year, &amp;month, &amp;day);    //输入年月日
    n = number(year, month, day);
    if ((n % 5) &lt; 4 &amp;&amp; (n % 5) &gt; 0)    //余数是1或2或3时说明在打渔，否则在晒网
        printf(&quot;%d：%d：%d 打鱼\n&quot;, year, month, day);
    else
        printf(&quot;%d：%d：%d 晒网\n&quot;, year, month, day);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入年月日
2011 1 4
2011：1：4 晒网
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例主要有以下两个技术要点：</p>
<p>(1) 判断输入的年份（2011 年以后包括 2011 年）是否为闰年，这里自定义函数 leap() 来进行判断。该函数的核心内容就是闰年的判断条件即能被 4 整除但不能被 100 整除，或能被 400 整除。</p>
<p>(2) 求输入日期距 2011 年 1 月 1 日有多少天。首先判断 2011 年距输入的年份有多少年，这其中有多少年是闰年就将 sum 加多少个 366，有多少年是平年便将 sum 加上多少个 365。</p>
<p>其次要将 12 个月每月的天数存到数组中，因为闰年 2 月份的天数有别于平年，故采用两个数组 a 和 b 分别存储。若输入年份是平年，月份为 m 时就在前面累加日期的基础上继续累加存储着平年每月天数的数组的前 m-1 个元素，将累加结果加上输入的日期便求出了最终结果。闰年的算法类似。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：3、百元买鸡]]></title>
        <id>https://acoldfront.github.io/post/c-example3/</id>
        <link href="https://acoldfront.github.io/post/c-example3/">
        </link>
        <updated>2020-05-05T03:39:52.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡问题”，鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)使用 for 语句对 3 种鸡的数嫌在事先确定好的范围内进行穷举并判断，对满足条件的 3 种鸡的数量按指定格式输出，否则进行下次循环。</p>
<p>(2) 程序的代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
   int cook, hen, chick;   //定义变童为基本整型

    for (cook = 0; cook &lt;= 100; ++cook) {
        for (hen = 0; hen &lt;= 100; ++hen) {
            for (chick = 0; chick &lt;= 100; ++chick) {
                if ((5 * cook + 3 * hen + chick / 3) == 100 &amp;&amp; chick % 3 == 0 &amp;&amp; cook+hen+chick==100)
                    //(5 * cook + 3 * hen + chick / 3) == 100   判断钱数是否等于 100
                    //chick % 3 == 0    判断小鸡数是否能被 3 整除
                    //cook+hen+chick==100  判断购买的鸡数是否等于 100
                    printf(&quot;公鸡 %2d 只，母鸡 %2d 只，小鸡 %2d 只\n&quot;, cook, hen, chick);
            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>公鸡  0 只，母鸡 25 只，小鸡 75 只
公鸡  4 只，母鸡 18 只，小鸡 78 只
公鸡  8 只，母鸡 11 只，小鸡 81 只
公鸡 12 只，母鸡  4 只，小鸡 84 只
</code></pre>
<p>###技术要点： ###<br>
根据题意设公鸡、母鸡和雏鸡分别为 cock、hen 和 chick，如果 100 元全买公鸡，那么最多能买 20 只，所以 cock 的范围是大于等于 0 且小于等于 20；如果全买母鸡，那么最多能买 33 只，所以 hen 的范围是大于等于 0 且小于等于 33；如果 100 元钱全买小鸡，那么最多能买 99 只（根据题意小鸡的数量应小于 100 且是 3 的倍数）。</p>
<p>在确定了各种鸡的范围后进行穷举并判断，判断的条件有以下 3 点：<br>
(1) 所买的 3 种鸡的钱数总和为 100。<br>
(2) 所买的 3 种鸡的数量之和为 100。<br>
(3) 所买的小鸡数必须是 3 的倍数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：2、猴子吃桃问题]]></title>
        <id>https://acoldfront.github.io/post/c-example2/</id>
        <link href="https://acoldfront.github.io/post/c-example2/">
        </link>
        <updated>2020-05-05T03:29:51.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将第一天剩下的桃子吃掉一半，有多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，发现只剩下一个桃子了。编写程序求猴子第一天摘了多少个桃子。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将第一天剩下的桃子吃掉一半，有多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，发现只剩下一个桃子了。编写程序求猴子第一天摘了多少个桃子。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 定义 day、x1、x2 为基本整型，并为 day 和 x2 赋初值 9 和 1。</p>
<p>(2) 使用 while 语句由后向前推出第一天摘的桃子数。</p>
<p>(3) 输出结果。</p>
<p>(4) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int day, x1, x2;    //定义 day、x1、x2 3 个变董为基本整型
    day = 9;
    x2 = 1;
    while (day &gt; 0) {
        x1 = (x2 + 1) * 2;    //第一天的桃子数是第二天桃子数加1后的2倍
        x2 = x1;
        day--;      //因为从后向前推所以天数递减
    }
    printf(&quot;一共是%d个桃子&quot;, x1);  //输出桃子的总数
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>一共是1534个桃子
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例的思路基本上是先找出变量间的关系，也就是要明确第一天桃数和第二天桃子数之间的关系，即第二天桃子数加 1 的 2 倍等于第一天的桃子数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：1、三个数从小到大排序输出]]></title>
        <id>https://acoldfront.github.io/post/c-example1/</id>
        <link href="https://acoldfront.github.io/post/c-example1/">
        </link>
        <updated>2020-05-05T03:16:28.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>任意输入 3 个整数，编程实现对这 3 个整数由小到大进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>任意输入 3 个整数，编程实现对这 3 个整数由小到大进行排序。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)定义数据类型，本实例中 a、b、c、t 均为基本整型。</p>
<p>(2) 使用输入函数获得任意 3 个值赋给 a、b、c。</p>
<p>(3) 使用 if 语句进行条件判断，如果 a 大于 b，则借助于中间变量 t 互换 a 与 b 值， 依此类推比较 a 与 c、b 与 c，最终结果即为 a、b、c 的升序排列。</p>
<p>(4) 使用输出函数将 a、b、c 的值依次输出。</p>
<p>(5) 程序的代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int a, b, c, t;    //定义4个基本整型变量a、b、c、t
    printf(&quot;请输入a,b,c:\n&quot;);    //双引号内的普通字符原样输出并换行
    scanf(&quot;%d,%d,%d&quot;, &amp;a, &amp;b, &amp;c);      //输入任意3个数

    if (a &gt; b) {    //如果a大于b,借助中间变量t实现a与b值的互换
        t = a;
        a = b;
        b = t;
    }
    if (a &gt; c) {    //如果a大于c,借助中间变量t实现a与c值的互换
        t = a;
        a = c;
        c = t;
    }
    if (b &gt; c) {    //如果b大于c,借助中间变量t实现b与c值的互换
        t = b;
        b = c;
        c = t;
    }

    printf(&quot;三个数的顺序为：%d,%d,%d&quot;, a, b, c);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入a,b,c:
5,2,1
三个数的顺序为：1,2,5
</code></pre>
<h3 id="脚下留神">脚下留神：</h3>
<p>本实例使用 scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); 从键盘中获得任意 3 个数。在输入数据时，在两个数据之间以一个或多个空格间隔，也可以用 Enter 健、Tab 键，不能用逗号作为两个数据间的分隔符。 如果用格式输入函数 scanf(&quot;％d,％d,%d&quot;,&amp;a,&amp;b,&amp;c) 输入数据，两个数据之间要用“,”做间隔。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bandizip(跨平台解压缩软件) v7.04 企业激活版]]></title>
        <id>https://acoldfront.github.io/post/bandizip/</id>
        <link href="https://acoldfront.github.io/post/bandizip/">
        </link>
        <updated>2020-04-21T08:53:47.000Z</updated>
        <summary type="html"><![CDATA[<p>虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p>
]]></summary>
        <content type="html"><![CDATA[<p>虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p>
<!-- more -->
<h3 id="主要功能">主要功能</h3>
<hr>
<p>支持操作系统: Windows Vista/7/8/10 (x86/x64/ARM64)<br>
许可类型：免费软件(EULA)<br>
全能的压缩/解压/浏览/编辑软件<br>
可提取30多种格式，包括RAR/RAR5/7Z/ZIP等<br>
包含密码压缩和分卷压缩功能<br>
支持多核高速压缩</p>
<h3 id="压缩">压缩</h3>
<hr>
<p>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7), ISO(joliet), GZ, XZ<br>
ZIP文件修改（添加/删除/重命名）<br>
支持多核并行，压缩速度可提升至多达6倍<br>
加密压缩<br>
支持AES256加密算法<br>
支持4GB 以上大小的文件压缩<br>
对ZIP格式支持Unicode或MBCS文件名<br>
对ZIP/7z格式可进行分卷压缩</p>
<h3 id="解压">解压</h3>
<hr>
<p>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ, IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ, TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ<br>
轻松查看压缩包内文件<br>
可只解压选定文件，支持拖拽解压<br>
可对ZIP和RAR格式添加注释<br>
一步解压TGZ/TBZ格式的文件</p>
<h3 id="功能多样">功能多样</h3>
<hr>
<p>测试文件完整性以确定压缩包是否损坏<br>
支持修改代码页改<br>
可集成至资源管理器右键菜单<br>
<img src="https://acoldfront.github.io//post-images/1587459441655.png" alt="" loading="lazy"></p>
<h3 id="更新日志">更新日志</h3>
<hr>
<p><a href="https://www.bandisoft.com/bandizip/history/">https://www.bandisoft.com/bandizip/history/</a></p>
<h3 id="破解教程">破解教程</h3>
<hr>
<p>去密钥检测，去联网验证、无需断网激活，不反弹！<br>
此企业版离线激活密钥来源PYG TEAM的成员分享<br>
7系列版本，安装后，下载破解补丁，破解后，使用激活码：<br>
00000000-ENT000000-0000000000-16210000<br>
邮箱地址：可任意填写，即随意填个假冒邮箱格式</p>
<p>如何使用？<br>
去验证补丁放安装目录运行，然后启动软件注册；<br>
邮箱地址：可任意填写，激活密钥使用上面这个。</p>
<p><a href="https://pan.baidu.com/s/11b-QgNy7bSagcZAbaL1Ggg">链接: https://pan.baidu.com/s/11b-QgNy7bSagcZAbaL1Ggg 提取码: jpfu</a></p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p>Bandizip各版本功能比较（自v7.0开始分为标准版/专业版/企业版）<br>
<a href="https://www.bandisoft.com/bandizip/help/edition-comparison">https://www.bandisoft.com/bandizip/help/edition-comparison</a></p>
<p>官网下载<br>
6系列版本：【原生无广告】<br>
<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE">安装版：https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE</a></p>
<p><a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP">32位便携版：https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP</a></p>
<p><a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP">64位便携版：https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP</a></p>
<p>7系列版本：<br>
<a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE">安装版：http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE</a></p>
<p><a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-PORTABLE.ZIP">便携版：http://dl.bandisoft.com/bandizip.std/BANDIZIP-PORTABLE.ZIP</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[思维导图软件 XMind ZEN 2020 v10.1.2 全平台 完美破解版]]></title>
        <id>https://acoldfront.github.io/post/xmind-zen-2020/</id>
        <link href="https://acoldfront.github.io/post/xmind-zen-2020/">
        </link>
        <updated>2020-04-07T22:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
<!-- more -->
<p>XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。</p>
<p>这两年思维导图突然就火起来了，各种思维导图软件也是雨后春笋般冒出来了，自 Xmind 发布以来就受到全球多个国家的办公一族喜爱。而 XMind 开发团队成员也在不断的去改进产品以提供优秀的生产力工具和服务，帮助人们节省时间并提升效率为目标。<br>
<img src="https://acoldfront.github.io//post-images/1579860380835.png" alt="" loading="lazy"></p>
<p>全新内核，经典 XMind 体验。<br>
我们努力了3年，100% 重写了思维导图引擎的每一个细节，XMind: ZEN 对 XMind 8 做到了完全兼容，让你有一种全新却不失经典的体验。</p>
<p>无人可超越，只有超越自己。<br>
对所有主题进行了重新设计，为您的每一张导图都注入新的活力。字体渲染也得到了极大的改进，让每一张思维导图既美观又专业。</p>
<p>我们专注，为了让您更专注。<br>
ZEN 模式，寓意为禅。让专注变成一种习惯。</p>
<p>全新 Snowbrush 引擎<br>
我们努力了3年，100% 重写了思维导图的引擎，着眼在未来的黑科技上，提升了思维导图的展示效果，丰富了绘图的元素。</p>
<p>充满惊喜的主题<br>
XMind: ZEN 对所有主题进行了重新设计，为您的每一张导图都注入新的活力，专业的同时又不失丰富元素，好看到让人羡慕。</p>
<p>Font Rendering<br>
由于极大地改进了字体的渲染技术，无论你用 Mac 还是 Windows 创建思维导图，所有文字都以同一样式清晰呈现。XMind: ZEN 精选多款优质字体，爱上编辑导图，从未如此简单。</p>
<p>Markdown<br>
我们相信 Markdown 会为你带来更好的使用体验，将做好的图导出为 Markdown 格式后，会让你更易于阅读。</p>
<p>集专注于 ZEN 模式<br>
ZEN 模式，寓意为禅，让专注变成一种习惯。进入 ZEN 模式，隐藏页面内多余的元素，帮助你全神贯注地绘制每一个主题，心无旁骛地完成工作。</p>
<p>贴纸，原创的更好<br>
设计师原创的贴纸，每一个都精心绘制，更准确地满足你的需求，精彩无处不在。</p>
<p>100% 对 XMind 8 兼容<br>
XMind: ZEN 对 XMind 8 做到了完全兼容，所有 XMind 8 拥有的图形结构，在 XMind: ZEN 中都能完美展现。</p>
<p>导出PDF和印象笔记<br>
将思维导图导出为矢量的 PDF 文件，方便您将导图随意放大和清晰地打印。印象笔记的粉丝们还会惊喜地发现只需简单地点击，便可将导图分享到印象笔记中。</p>
<h2 id="更新日志">###更新日志</h2>
<p>10.1.1</p>
<p>Xmind ZEN更名为Xmind 2020</p>
<ol>
<li>修复了旧版本升级后，启动时可能报错的问题；</li>
<li>修复了 Windows 下可能无法检测到部分字体的问题；</li>
<li>修复了改变字体大小时，可能影响到其他主题的问题；</li>
<li>修复了编辑方程后，画布可能卡住的问题；</li>
<li>修复了输入空方程时会报错的问题；</li>
<li>修复了部分其他已知问题。</li>
</ol>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于官网最新版本破解</p>
<p>破解授权，移除验证，去除试用提示</p>
<p>能正常导出图片无水印，PDF无水印，导出word，粘贴图片等高级功能</p>
<p>v2版本导出PNG缩放大小已修复</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>将app.asar放入XMind-ZEN安装目录的resources文件夹下替换</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/175dlcFsxq9RsiB_BGt0erw">链接: https://pan.baidu.com/s/175dlcFsxq9RsiB_BGt0erw 提取码: 8kh4</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android VSCO v158 破解版]]></title>
        <id>https://acoldfront.github.io/post/vsco/</id>
        <link href="https://acoldfront.github.io/post/vsco/">
        </link>
        <updated>2020-04-06T10:17:57.000Z</updated>
        <summary type="html"><![CDATA[<p>VSCO是时下一款非常流行的摄影App。VSCO支持的功能包括摄影App，语音通讯、相机拍照、照片编辑和照片分享等功能。但是其核心还是滤镜非常强大！</p>
]]></summary>
        <content type="html"><![CDATA[<p>VSCO是时下一款非常流行的摄影App。VSCO支持的功能包括摄影App，语音通讯、相机拍照、照片编辑和照片分享等功能。但是其核心还是滤镜非常强大！</p>
<!-- more -->
<p>随着版本的不断升级，VSCO 逐渐成了一款功能强大的摄影App，包含了相机拍照、照片编辑和照片分享三大功能。虽如此，但VSCO依然保持了简单的使用方式(对于已上手用户而言使用非常简单)，可以利用VSCO内置包含了强大手动控制功能的相机进行拍摄，也可以利用VSCO内数量众多的胶片滤镜、照片基础调整工具对照片进行处理，创造出令人着迷、胶片味道十足的手机摄影作品。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>破解会员，解锁全部滤镜</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1jQyZyfgmDLCubXhswtD77g">链接: https://pan.baidu.com/s/1jQyZyfgmDLCubXhswtD77g 提取码: r7sg </a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WinSnap v5.2.3 便携破解版]]></title>
        <id>https://acoldfront.github.io/post/winsnap/</id>
        <link href="https://acoldfront.github.io/post/winsnap/">
        </link>
        <updated>2020-04-05T03:17:37.000Z</updated>
        <summary type="html"><![CDATA[<p>WinSnap是一款屏幕捕获软件，能够让您得心应手地捕获到需要的屏幕截图。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WinSnap是一款屏幕捕获软件，能够让您得心应手地捕获到需要的屏幕截图。</p>
<!-- more -->
<p>捕捉图像方式灵活，主要可以捕捉整个屏幕、活动窗口、选定区域等，图像输出方式多样，主要包括文件、剪贴板、和邮件。软件具有设置捕捉前延时、自定义捕捉热键、图像文件自动按时间或模板命名、捕捉成功声音提示、预览捕捉图片、图像打印、图像水印、图像反色、图像翻转、图像旋转等功能。<br>
WinSnap轻巧、快速、简单、友好提供截图和图像编辑功能。和其它截图软件相比其最大亮点在于WinSnap可以捕获或去除Winodws 7的 Aero玻璃效果。WinSnap内置了阴影，反射，旋转，水印等效果，支持各种图像格式，并支持自动保存。</p>
<p><strong>WinSnap 主要特点：</strong><br>
[+]灵活的屏幕捕捉功能<br>
[+]内置图像编辑器：箭头，矩形，文本注释<br>
[+]设计用于捕获 Windows Aero 的干净背景<br>
[+]支持透明度的 PNG 和 TIFF 图像格式<br>
[+]高级自动保存和自动复制选项<br>
[+]常规键盘和鼠标控制（打印屏幕更换）<br>
[+]可配置工具菜单中打开外部图像编辑器<br>
[+]小和快速的图像编辑器，比画图更小<br>
[+]多语言用户界面（基于Unicode）<br>
<img src="https://acoldfront.github.io//post-images/1586056964047.png" alt="" loading="lazy"></p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>便携版制作</p>
<p>强制破解免授权，无需许可证密钥，截图保存无水印</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>若出现：从服务器返回了一个参照<br>
对着程序，右键，属性，兼容性，勾选以管理员身份运行。</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1AVppD7OUoGqk3n5sOl9cDA">链接: https://pan.baidu.com/s/1AVppD7OUoGqk3n5sOl9cDA 提取码: 241q</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WinRAR v5.90 Final 便携版]]></title>
        <id>https://acoldfront.github.io/post/winrar/</id>
        <link href="https://acoldfront.github.io/post/winrar/">
        </link>
        <updated>2020-04-01T10:40:15.000Z</updated>
        <summary type="html"><![CDATA[<p>WinRAR是一款功能强大的压缩包管理器，它是档案工具RAR在 Windows环境下的图形界面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WinRAR是一款功能强大的压缩包管理器，它是档案工具RAR在 Windows环境下的图形界面。</p>
<!-- more -->
<p>WinRAR可用于备份数据，缩减电子邮件附件的大小，解压缩从 Internet 上下载的RAR、ZIP及其它类型文件，WinRAR并且可以新建 RAR 及 ZIP 格式等的压缩类文件。WinRAR非常实用、方便，中文化工作更为完善，WinRAR包括主工作界面、右键菜单，甚至连十万字的 .hlp 在线帮助文件、使用手册文件、Readme 文件都完全是中文内容。</p>
<p><strong>WinRAR软件特点</strong></p>
<p>1、压缩率更高</p>
<p>WinRAR 在 DOS 时代就一直具备这种优势，经过多次试验证明，WinRAR 的 RAR 格式一般要比其他的 ZIP 格式高出 10%～30% 的压缩率，尤其是它还提供了可选择的、针对多媒体数据的压缩算法。</p>
<p>2、对多媒体文件有独特的高压缩率算法</p>
<p>WinRAR 对 WAV、BMP 声音及图像文件可以用独特的多媒体压缩算法大大提高压缩率，虽然我们可以将 WAV、BMP 文件转为 MP3．JPG 等格式节省存储空间，但不要忘记 WinRAR 的压缩可是标准的无损压缩。</p>
<p>3、能完善地支持ZIP格式并且可以解压多种格式的压缩包</p>
<p>虽然其他软件也能支持 ARJ、LHA 等格式，但却需要外挂对应软件的 DOS 版本，实在是功能有限。但WinRAR就不同了，不但能解压多数压缩格式，且不需外挂程序支持就可直接建立 ZIP 格式的压缩文件，所以我们不必担心离开了其他软件如何处理 ZIP 格式的问题。</p>
<p>4、设置项目非常完善，并且可以定制界面</p>
<p>通过开始选单的程序组启动WinRAR，在其主界面中选择“选项”选单下的“设置”打开设置窗口，分为常规、压缩、路径、文件列表、查看器、综合六大类，非常丰富，通过修改它们，可以更好地使用 WinRAR。实战：如果同时安装了某款压缩软件与 WinRAR，ZIP 文件的关联经常发生混乱，一般我们只需进入设置窗口，选“综合”标签，将“ WinRAR 关联文件”一栏中的 ZIP 一项打勾，确定后就可使 ZIP 文件与 WinRAR 关联，反之如果将勾去掉，则 WinRAR 自动修改注册表使 ZIP 重新与这个压缩软件的关联。</p>
<p>5、对受损压缩文件的修复能力极强</p>
<p>在网上下载的ZIP、RAR类的文件往往因头部受损的问题导致不能打开，而用WinRAR调入后，只须单击界面中的“修复”按钮就可轻松修复，成功率极高。</p>
<p>6、可以不必解压就可查看压缩包信息</p>
<p>使用WinRAR，选中文件点击信息就可查看压缩包信息。</p>
<p>7、辅助功能设置细致</p>
<p>WinRAR可以在压缩窗口的“备份”标签中设置压缩前删除目标盘文件；可在压缩前单击“估计”按钮对压缩先评估一下；可以为压缩包加注释；可以设置压缩包的防受损功能，等等细微之处也能看出WinRAR的体贴周到。</p>
<p>8、压缩包可以锁住</p>
<p>使用WinRAR双击进入压缩包后，单击命令选单下的“锁定压缩包”就可防止人为的添加、删除等操作，保持压缩包的原始状态。</p>
<p>9、压缩包可以看隐藏文件</p>
<p>你还在为Autorun病毒发愁？Winrar就提供了“透视”功能。把那些隐藏属性的文件一目了然。<br>
<img src="https://acoldfront.github.io//post-images/1585737802815.png" alt="" loading="lazy"></p>
<h3 id="更新日志">更新日志</h3>
<hr>
<p>1.对于具有16个或更多内核的CPU，RAR压缩速度得到了提高。<br>
2.对于创建高度可压缩的数据类型，“快速”方法（等效于-m1命令行）在创建RAR5归档文件时可以实现较高的压缩率。<br>
3.使用的最大线程数从32增加到64。命令行-mt <threads>开关接受从1到64的值。<br>
4. WinRAR设置的“常规”页面上的“多线程”参数将替换为“线程”输入字段，您可以在其中指定所需的CPU线程数。取值范围是1到最大可用逻辑CPU单元数。<br>
5. WinRAR在浏览档案内容时显示打包和解压缩的文件夹大小。<br>
6.“总文件夹”字段添加到WinRAR“信息”命令显示的归档参数列表中。<br>
Windows资源管理器中存档属性中的“存档”页面添加了相同的字段。<br>
7.如果读取存档内容花费的时间很长，则会显示一个包含进度条和“取消”按钮的窗口。它对于访问内容速度较慢的存档格式很有用，例如大型的基于TAR的存档（例如.tar.gz和tar.bz2）<br>
8.可以调整归档和提取进度窗口的大小，也可以调整其他一些命令的进度窗口的大小。<br>
9.改进了具有恢复记录且无数据移位的RAR5档案的“修复”性能。<br>
它在WinRAR 5.80中恶化，现在恢复到原始水平。<br>
10.对具有加密文件名的RAR5归档文件执行基于恢复记录的修复时，不会发出密码提示。可以在不提供密码的情况下执行此命令。<br>
11.如果“转换档案”命令中没有用于转换档案的文件夹，则WinRAR尝试创建该文件夹。<br>
以前的版本无法在不存在的目标文件夹中创建转换后的归档。<br>
12.添加了对GZIP存档的提取支持，并带有可选的标头校验和字段。<br>
13.修复的错误：<br>
a）在处理具有有效恢复记录的归档文件时，“修复”命令可能会错误地显示“恢复记录已损坏”消息。<br>
此消息并未阻止进一步的修复操作；<br>
b）如果默认压缩配置文件中的“快速打开信息”选项设置为“不添加”，并且此配置文件是通过某些命令或对话框加载的，则WinRAR在浏览RAR归档文件的内容时会忽略快速打开信息。<br>
例如，它是在打开存档或密码对话框之后发生的；<br>
c）Ctrl + C“复制”快捷键在存档注释窗口中不起作用；<br>
d）如果设置了“将每个文件放入单独的存档”和“在子文件夹中存档”选项，则WinRAR将忽略在存档名称字段中指定的目标路径。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>官方版集成许可</p>
<p>便携版制作，集成x64和x86版本</p>
<p>能够关联文件</p>
<p>集成无限制许可文件</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1wDn8z5MBKJKyXgiJk7DwHg">链接: https://pan.baidu.com/s/1wDn8z5MBKJKyXgiJk7DwHg 提取码: 1b4r</a></p>
]]></content>
    </entry>
</feed>