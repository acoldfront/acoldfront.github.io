<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-03-26T03:31:02.698Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[全新的思维导图软件 XMind ZEN 2020 v10.1.0 中文多语特别版]]></title>
        <id>https://acoldfront.github.io/post/xmind-zen-2020/</id>
        <link href="https://acoldfront.github.io/post/xmind-zen-2020/">
        </link>
        <updated>2020-03-25T22:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
<!-- more -->
<p>XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。</p>
<p>这两年思维导图突然就火起来了，各种思维导图软件也是雨后春笋般冒出来了，自 Xmind 发布以来就受到全球多个国家的办公一族喜爱。而 XMind 开发团队成员也在不断的去改进产品以提供优秀的生产力工具和服务，帮助人们节省时间并提升效率为目标。<br>
<img src="https://acoldfront.github.io//post-images/1579860380835.png" alt="" loading="lazy"></p>
<p>全新内核，经典 XMind 体验。<br>
我们努力了3年，100% 重写了思维导图引擎的每一个细节，XMind: ZEN 对 XMind 8 做到了完全兼容，让你有一种全新却不失经典的体验。</p>
<p>无人可超越，只有超越自己。<br>
对所有主题进行了重新设计，为您的每一张导图都注入新的活力。字体渲染也得到了极大的改进，让每一张思维导图既美观又专业。</p>
<p>我们专注，为了让您更专注。<br>
ZEN 模式，寓意为禅。让专注变成一种习惯。</p>
<p>全新 Snowbrush 引擎<br>
我们努力了3年，100% 重写了思维导图的引擎，着眼在未来的黑科技上，提升了思维导图的展示效果，丰富了绘图的元素。</p>
<p>充满惊喜的主题<br>
XMind: ZEN 对所有主题进行了重新设计，为您的每一张导图都注入新的活力，专业的同时又不失丰富元素，好看到让人羡慕。</p>
<p>Font Rendering<br>
由于极大地改进了字体的渲染技术，无论你用 Mac 还是 Windows 创建思维导图，所有文字都以同一样式清晰呈现。XMind: ZEN 精选多款优质字体，爱上编辑导图，从未如此简单。</p>
<p>Markdown<br>
我们相信 Markdown 会为你带来更好的使用体验，将做好的图导出为 Markdown 格式后，会让你更易于阅读。</p>
<p>集专注于 ZEN 模式<br>
ZEN 模式，寓意为禅，让专注变成一种习惯。进入 ZEN 模式，隐藏页面内多余的元素，帮助你全神贯注地绘制每一个主题，心无旁骛地完成工作。</p>
<p>贴纸，原创的更好<br>
设计师原创的贴纸，每一个都精心绘制，更准确地满足你的需求，精彩无处不在。</p>
<p>100% 对 XMind 8 兼容<br>
XMind: ZEN 对 XMind 8 做到了完全兼容，所有 XMind 8 拥有的图形结构，在 XMind: ZEN 中都能完美展现。</p>
<p>导出PDF和印象笔记<br>
将思维导图导出为矢量的 PDF 文件，方便您将导图随意放大和清晰地打印。印象笔记的粉丝们还会惊喜地发现只需简单地点击，便可将导图分享到印象笔记中。</p>
<h2 id="更新日志">###更新日志</h2>
<p>10.1.0</p>
<p>LaTeX方程</p>
<p>立即插入专业的方程，例如数学和化学方程。</p>
<p>增强的ZEN模式</p>
<p>ZEN模式现在支持查看快捷键、编辑样式、插入标记等操作。</p>
<p>自定义快速样式</p>
<p>用风格编辑器自定义快速样式，区分主题更加轻松便捷。</p>
<p>Word导入</p>
<p>从Word到XMind -整理点子和知识的全新开始。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于官网最新版本破解</p>
<p>破解授权，移除验证，去除试用提示</p>
<p>能正常导出图片无水印，PDF无水印，导出word，粘贴图片等高级功能</p>
<p>v2版本导出PNG缩放大小已修复</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>将app.asar放入XMind-ZEN安装目录的resources文件夹下替换</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p>在本文寻找！Good luck！😏</p>
<!-- 链接: https://pan.baidu.com/s/175dlcFsxq9RsiB_BGt0erw 提取码: 8kh4  -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库管理工具 PremiumSoft Navicat Premium v15.0.12 中文特别版]]></title>
        <id>https://acoldfront.github.io/post/navicat-premium/</id>
        <link href="https://acoldfront.github.io/post/navicat-premium/">
        </link>
        <updated>2020-03-23T04:55:18.000Z</updated>
        <summary type="html"><![CDATA[<p>Navicat premium是一款数据库管理工具。将此工具连接数据库，你可以从中看到各种数据库的详细信息。包括报错，等等。当然，你也可以通过他，登陆数据库，进行各种操作。Navicat Premium是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Navicat premium是一款数据库管理工具。将此工具连接数据库，你可以从中看到各种数据库的详细信息。包括报错，等等。当然，你也可以通过他，登陆数据库，进行各种操作。Navicat Premium是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p>
<!-- more -->
<p>Navicat Premium结合了其他Navicat成员的功能。有了这种连线到不同资料库类型的能力，Navicat Premium支持在 MySQL、SQLite、Oracle 及 PostgreSQL 之间传输资料。它支持大部分的 MySQL、SQLite、Oracle 及 PostgreSQL 功能，包括预存程序、事件、触发器、函式、检视等。<br>
Navicat Premium可以让你简单并快速的在多种资料库系统间传输资料，或传输一份以SQL格式及编码设计的纯文字档。<br>
不同的资料库的批次处理任务也可以设定排程并在指定的时间执行。其他功能包括汇入/汇出精灵、查询建立工具、报表产生器、资料同步、备份、工作排程及更多。</p>
<p>Navicat的的功能足以提供专业开发人员的所有需求，但是对资料库伺服器的新手来说又相当容易学习。<br>
Navicat Premium [2] 有三种平台版本- Microsoft Windows、Mac OS X及Linux。它可以让使用者连接本地/远端伺服器、提供一些实用的工具如资料/结构同步、汇入/汇出、备份/回复及报表以协助管理资料的流程。</p>
<p>Navicat Premium(导航猫数据库管理)是一个可多重连线资料库的管理工具，Navicat Premium(导航猫数据库管理)可以让你以单一程式同时连线到MySQL、SQLite、Oracle 及 PostgreSQL资料库，让管理不同类型的资料库更加的方便。 　Navicat Premium可以让你简单并快速的在多种资料库系统间传输资料，或传输一份以SQL格式及编码设计的纯文字档。</p>
<p>不同的资料库的批次处理任务也可以设定排程并在指定的时间执行。其他功能包括汇入/汇出精灵、查询建立工具、报表产生器、资料同步、备份、工作排程及更多。</p>
<p>Navicat的的功能足以提供专业开发人员的所有需求，但是对资料库伺服器的新手来说又相当容易学习。<br>
<img src="https://acoldfront.github.io//post-images/1580014704119.png" alt="" loading="lazy"></p>
<p>Navicat Cloud<br>
Navicat 提供 Navicat Cloud 服务给用户。同步你的连接设置、模型、查询和虚拟组到云。这样你就能随时随地实时访问他们。有了 Navicat Cloud，你可以善用一天中的每分每秒，以最大限度提高你的工作效率。了解更多›</p>
<p>安全连接<br>
Navicat 可以让你通过 SSH 通道创建安全的 SSH 阶段作业，确保两台主机之间的连接受到强大验证和安全加密的保护。验证方式可使用密码或公钥和私钥对。Navicat 亦支持 HTTP 通道，让你灵活地绕过限制直接数据库服务器连接的互联网服务供应商。</p>
<p>对象设计器<br>
使用专业的对象设计器创建、修改和设计所有数据库对象，例如：表、视图、函数、过程、索引、触发器和序列。无需编写复杂的 SQL 来创建和编辑对象，你会知道你正使用什么选项。</p>
<p>表查看器<br>
网格或表单查看<br>
使用网格查看添加、修改和删除记录。用类似数据表的功能浏览网格查看，例如排序和隐藏数据组，使用我们的助理编辑器：备注、十六进制、图像或更多</p>
<p>你也可以用表单查看操作记录。清楚显示记录的字段名和其值，不必担心误解数据。</p>
<p>外键数据选择<br>
在你的数据库使用外键关系锚定参考的查找表，并自动建立下拉列表。无需持续对照参考主表，你可以简化你的工作流程和提升效率。<br>
SQL 创建工具或编辑器</p>
<p>SQL 创建工具<br>
视觉化 SQL 创建工具让你创建和编辑查询或视图，而不必担心语法和正确命令的用法。选择你想在表中执行的操作，它会为你编写 SQL 语句。</p>
<p>自动完成代码<br>
使用我们的自动完成代码功能，能快速地在 SQL 编辑器中创建 SQL 语句。无论你想选择的是数据库对象的属性或 SQL关键字，你只需从下拉列表中选择。</p>
<p>数据库设计器<br>
逆向工程<br>
使用 Navicat 的逆向工程，你可以从一个现有的数据库创建数据库模型，可视化地显现和编辑你的数据库结构或创建一个图形模型，并由模型生成一个数据库。</p>
<p>正向工程和脚本生成<br>
同步到数据库功能给你充分了解所有数据库的差异。生成必要的同步脚本来更新目标数据库，并使其与模型相同。</p>
<p>导出 SQL 让你有机会全面控制最终的 SQL 脚本，生成参照完整性规则，生成模型的独立部份、注释、字符集等。它可以节省你的工作时间。</p>
<p>PL/SQL 代码调试器<br>
PL/SQLPL/PGSQL<br>
PL/SQL 调试器提供的功能，如设置断点，步进通过程序，查看和修改变量值，及查看调用堆栈。你可以直接从 Navicat 的工作区中调试 PL/SQL 代码如过程和函数、对象方法和触发器。</p>
<p>数据处理工具<br>
导入或导出向导<br>
从不同格式的文件导入数据到表，例如 Access、Excel、XML、TXT、CSV、JSON 及更多。而且，在设置数据源连接后，你可以从 ODBC 导入数据。只需简单地选择你要导入的表，或使用添加查询按钮指定查询。同样，你可以将数据导出到各种格式，如 Excel、TXT、CSV、DBF、XML 等。</p>
<p>数据传输<br>
在多个不同的数据库系统间轻松地传输数据 – MySQL、MariaDB、SQL Server、Oracle、PostgreSQL 和 SQLite 数据库。你可以选择以指定的 SQL 格式和编码导出数据为 SQL 文件。这个功能可大大的简化迁移数据的进程。</p>
<p>数据或结构同步<br>
从一个数据库中以详细的分析进程传输数据到另外一个数据库。同样，你可以比对并修改表的结构。在数据和结构同步中，目标数据库可以在源服务器，也可以在其他的服务器。</p>
<p>备份或还原<br>
定期备份数据库对用户是相当重要的。备份或还原全部表、记录、视图等。如果数据损坏，不用再重做，让你能高枕无忧。</p>
<p>计划<br>
不同数据库的设置文件可以创建在单一批处理作业，这样你就可以设置计划并在指定的时间运行。批处理作业可以创建的对象包括打印报表、数据库备份、查询、数据传输、数据同步、导入和导出。当任务完成后，Navicat 可自动传送电子邮件通知给你指定的收件人。此外，导出的文件或打印的报表可以添加到批处理作业作为电子邮件附件，让你可以轻易与其他人共享你的数据。<br>
报表创建工具或查看器 *只限于 Windows 版本</p>
<p>使用我们的用户友好 GUI 报表创建工具创建各种不同类型的报表。设计发票、统计、邮寄标签及更多其他报表。输出报表到多种格式 – text、PDF、Lotus、Excel、Graphic、Html 及更多。</p>
<p>Navicat Report Viewer 可让你浏览由报表创建工具设计的报表。最酷的是你可以与计算机沒有安装 Navicat，但安装了 Navicat Report Viewer 的人共享报表。</p>
<p>实用工具<br>
ER 图表<br>
ER 图表查看能通过以图形格式显示数据库结构来帮助你了解你的数据库，让你可以看到数据库中表之间的关联。</p>
<p>连接颜色或虚拟组<br>
连接颜色功能可以让你立刻知道你连接到哪个服务器。显示在子窗口工具栏的颜色指示，用于识别连接和它们的数据库对象。虚拟组功能分类对象到不用的组，令对象和连接有一个更好的组织。</p>
<p>树或对象筛选<br>
使用树或对象筛选功能收窄显示数据对象的列表。简单地需输入文本，然后只会显示符合指定字符串开始的数据库对象。</p>
<p>收藏夹<br>
Navicat 让你更容易地回到你常访问的数据库对象。通过添加路径到收藏夹列表，你只需一次点击就可以打开这些数据库对象。</p>
<p>系统需求<br>
Windows<br>
Microsoft Windows XP SP3、Vista、Windows 7、Windows 8、Windows 8.1、Windows 10、Server 2003、Server 2008、Server 2012</p>
<p>Mac<br>
Mac OS X 10.7 或以上版本<br>
Intel 处理器</p>
<p>Linux<br>
Ubuntu 12.04、Ubuntu 14.04、CentOS 6.7、CentOS 7、Fedora 22、Fedora 23、Linux Mint 13、Linux Mint 17.3、openSUSE 13.2、openSUSE 42.1</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于DeltaFox大神Navicat_Keygen_Patch_v5.6  Crazer汉化</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>使用前查看“使用说明&quot;文档<br>
或者<br>
<a href="https://acoldfront.github.io/post/navicat-keygen-patch/">查看Navicat产品_补丁_注册机 使用教程</a></p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p>在本文寻找！Good luck！😏</p>
<!-- 链接: https://pan.baidu.com/s/1N32CbhM_-hIUdH_8zVzOPg 提取码: 4vgd -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言求最小公倍数和最大公约数四种算法(经典)]]></title>
        <id>https://acoldfront.github.io/post/cdivisormultiple/</id>
        <link href="https://acoldfront.github.io/post/cdivisormultiple/">
        </link>
        <updated>2020-03-19T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p>最小公倍数：数论中的一种概念，两个整数公有的倍数成为他们的公倍数，其中一个最小的公倍数是他们的最小公倍数，同样地，若干个整数公有的倍数中最小的正整数称为它们的最小公倍数，维基百科：<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B8">定义点击打开链接</a><br>
求最小公倍数算法：<br>
最小公倍数=两整数的乘积÷最大公约数</p>
<p>求最大公约数算法：<br>
(1)辗转相除法：<br>
有两整数a和b：<br>
① a%b得余数c<br>
② 若c=0，则b即为两数的最大公约数<br>
③ 若c≠0，则a=b，b=c，再回去执行①</p>
<p>例如求27和15的最大公约数过程为：<br>
27÷15 余12，15÷12余3，12÷3余0，因此，3即为最大公约数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//辗转相除法求最大公约数
int main(void) {
    int m, n;
    int a, b, c;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    while (b != 0) {   //余数不为0，继续相除，直到余数为0
        c = a % b;
        a = b;
        b = c;
    }
    printf(&quot;最大公约数：%d\n&quot;, a);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / a);
    return 0;
}
</code></pre>
<p>提供一种简写的方式：</p>
<pre><code class="language-c">int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
</code></pre>
<p>⑵ 相减法：<br>
有两整数a和b：<br>
① 若a&gt;b，则a=a-b<br>
② 若a&lt;b，则b=b-a<br>
③ 若a=b，则a（或b）即为两数的最大公约数<br>
④ 若a≠b，则再回去执行①</p>
<p>例如求27和15的最大公约数过程为：<br>
27－15＝12( 15&gt;12 ) 15－12＝3( 12&gt;3 )<br>
12－3＝9( 9&gt;3 ) 9－3＝6( 6&gt;3 )<br>
6－3＝3( 3==3 )<br>
因此，3即为最大公约数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//相减法求最大公约数
int main(void) {
    int m, n;
    int a, b, c;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    while (a != b) {   //a, b不相等，大数减小数，直到相等为止。
        if (a &gt; b)
            a = a - b;
        else
            b = b - a;
    }
    printf(&quot;最大公约数：%d\n&quot;, a);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / a);
    return 0;
}
</code></pre>
<p>⑶穷举法：<br>
有两整数a和b：<br>
① i=1<br>
② 若a，b能同时被i整除，则t＝i<br>
③ i++<br>
④ 若 i &lt;= a(或b)，则再回去执行②<br>
⑤ 若 i &gt; a(或b)，则t即为最大公约数，结束</p>
<p>改进：<br>
① i= a(或b)<br>
② 若a，b能同时被i整除，则i即为最大公约数，<br>
结束<br>
③ i--，再回去执行②</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//穷举法求最大公约数
int main(void) {
    int m, n;
    int a, b, i, t;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    for (i = 1; i &lt;= a; ++i) {
        if (a % i == 0 &amp;&amp; b % i == 0)
            t = i;
    }
    /*  改进后的
    for (t= a; t&gt;0; t-- )
        if ( a%t == 0 &amp;&amp; b%t ==0 )
            break; 
    */
    printf(&quot;最大公约数：%d\n&quot;, t);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / t);
    return 0;
}
</code></pre>
<pre><code class="language-c"> //穷举法求最小公倍数
for (i = a;; i++)
    if (i % a == 0 &amp;&amp; i % b == 0) break;
printf(&quot;最小公倍数：%d\n&quot;, i);

//多个数的最大公约数和最小公倍数
for (i = a; i &gt; 0; i--)
    if (a % i == 0 &amp;&amp; b % i == 0 &amp;&amp; c % i == 0)
        break;
printf(&quot;最大公约数：%d\n&quot;, i);
for (i = a;; i++)
    if (i % a == 0 &amp;&amp; i % b == 0 &amp;&amp; i % c == 0)
        break;
printf(&quot;最小公倍数：%d\n&quot;, i);
</code></pre>
<p>⑷取模法：<br>
求最小公倍数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最小公倍数
int main(void) {
    int x, y;
    int lcm;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    if (x &gt; y)
        lcm = x;
    else
        lcm = y;
    while (lcm % x || lcm % y)
        lcm++;
    printf(&quot;最小公倍数：%d\n&quot;, lcm);
    return 0;
}
</code></pre>
<p>求最大公约数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最大公约数
int main(void) {
    int x, y;
    int gcd;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    if (x &gt; y)
        gcd = y;
    else
        gcd = x;
    while (x % gcd || y % gcd)
        gcd--;
    printf(&quot;最大公约数：%d\n&quot;, gcd);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言指针详解]]></title>
        <id>https://acoldfront.github.io/post/czhizhen/</id>
        <link href="https://acoldfront.github.io/post/czhizhen/">
        </link>
        <updated>2020-03-18T07:53:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么需要指针">为什么需要指针?</h1>
<p>指针解决了一些编程中基本的问题。</p>
<p>第一，指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。</p>
<p>第二，指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。</p>
<p>第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p>
<h1 id="指针是什么">指针是什么？</h1>
<p>我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。</p>
<p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = 'a'。</p>
<p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<p>因此：<strong>指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</strong><br>
<img src="https://acoldfront.github.io//post-images/1584518311428.png" alt="" loading="lazy"></p>
<h2 id="为什么程序中的数据会有自己的地址">为什么程序中的数据会有自己的地址？</h2>
<p>弄清这个问题我们需要从操作系统的角度去认知内存。</p>
<p>电脑维修师傅眼中的内存是这样的：内存在物理上是由一组DRAM芯片组成的。<br>
<img src="https://acoldfront.github.io//post-images/1584518333082.png" alt="" loading="lazy"><br>
而作为一个程序员，我们不需要了解内存的物理结构，操作系统将DRAM等硬件和软件结合起来，给程序员提供的一种对物理内存使用的抽象。<strong>这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作物理存储器</strong>。所有的虚拟地址形成的集合就是虚拟地址空间。<br>
<img src="https://acoldfront.github.io//post-images/1584518355076.png" alt="" loading="lazy"><br>
在程序员眼中的内存应该是下面这样的。（假设使用的是32位系统平台，虚拟存储空间为4GB）<br>
<img src="https://acoldfront.github.io//post-images/1584518367152.png" alt="" loading="lazy"><br>
也就是说，虚拟存储器是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。如上图中，这是一个4GB的虚拟存储器的模型，它一共有4x1024x1024x1024 个字节，那么它的虚拟地址范围就是 0 ~ 4x1024x1024x1024-1 。</p>
<p><strong>由于内存中的每一个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。</strong><br>
下面用代码说明</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    char ch = 'a';
    int  num = 97;
    printf(&quot;ch 的地址:%p\n&quot;,&amp;ch);   //ch 的地址:0028FF47
    printf(&quot;num的地址:%p\n&quot;,&amp;num);  //num的地址:0028FF40
    return 0;
}
</code></pre>
<p><img src="https://acoldfront.github.io//post-images/1584518411108.png" alt="" loading="lazy"><br>
指针的值实质是内存单元（即字节）的编号，所以指针 单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。<br>
我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节）<br>
<img src="https://acoldfront.github.io//post-images/1584518428498.png" alt="" loading="lazy"></p>
<h1 id="变量和内存">变量和内存</h1>
<p>为了简单起见，这里就用上面例子中的  int num = 97 这个局部变量来分析变量在内存中的存储模型。<br>
<img src="https://acoldfront.github.io//post-images/1584518486461.png" alt="" loading="lazy"><br>
已知：num的类型是int，占用了4个字节的内存空间，其值是97，地址是0028FF40。我们从以下几个方面去分析。</p>
<p>1、内存的数据</p>
<p>内存的数据就是变量的值对应的二进制，一切都是二进制。97的二进制是 : 00000000 00000000 00000000 0110000 , 但使用的<strong>小端模式</strong>存储时，低位数据存放在低地址，所以图中画的时候是倒过来的。</p>
<p>2、内存数据的类型</p>
<p>内存的数据类型决定了这个数据占用的字节数，以及计算机将如何解释这些字节。num的类型是int，因此将被解释为 一个整数。</p>
<p>3、内存数据的名称</p>
<p>内存的名称就是变量名。实质上，内存数据都是以地址来标识的，根本没有内存的名称这个说法，这只是高级语言提供的抽象机制 ，方便我们操作内存数据。而且在C语言中，并不是所有的内存数据都有名称，例如使用malloc申请的堆内存就没有。</p>
<p>4、内存数据的地址</p>
<p>如果一个类型占用的字节数大于1，则其变量的地址就是地址值最小的那个字节的地址。因此num的地址是 0028FF40。 内存的地址用于标识这个内存块。</p>
<p>5、内存数据的生命周期</p>
<p>num是main函数中的局部变量，因此当main函数被启动时，它被分配于栈内存上，当main执行结束时，消亡。</p>
<p>如果一个数据一直占用着他的内存，那么我们就说他是“活着的”，如果他占用的内存被回收了，则这个数据就“消亡了”。C语言中的程序数据会按照他们定义的位置，数据的种类，修饰的关键字等因素，决定他们的生命周期特性。实质上我们程序使用的内存会被逻辑上划分为：  栈区，堆区，静态数据区，方法区。不同的区域的数据有不同的生命周期。</p>
<p>无论以后计算机硬件如何发展，内存容量都是有限的，因此清楚理解程序中每一个程序数据的生命周期是非常重要的。</p>
<h1 id="指针变量-和-指向关系">指针变量 和 指向关系</h1>
<p>用来保存 指针 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。<br>
<img src="https://acoldfront.github.io//post-images/1584518528925.png" alt="" loading="lazy"><br>
上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。</p>
<p><strong>定义指针变量</strong></p>
<p>C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。</p>
<p>引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。</p>
<pre><code class="language-c">int a ; //int类型变量 a
int *a ; //int* 变量a
int arr[3]; //arr是包含3个int元素的数组
int (* arr )[3]; //arr是一个指向包含3个int元素的数组的指针变量


//-----------------各种类型的指针------------------------------

int* p_int; //指向int类型变量的指针 

double* p_double; //指向idouble类型变量的指针 

struct Student *p_struct; //结构体类型的指针

int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 

int(*p_arr)[3]; //指向含有3个int元素的数组的指针 

int** p_pointer; //指向 一个整形变量指针的指针
</code></pre>
<p><strong>取地址</strong></p>
<p>既然有了指针变量，那就得让他保存其它变量的地址，使用&amp; 运算符取得一个变量的地址。</p>
<pre><code class="language-c">int add(int a , int b)
{
    return a + b;
}

int main(void)
{
    int num = 97;
    float score = 10.00F;
    int arr[3] = {1,2,3};

    //-----------------------

    int* p_num = &amp;num;
    float* p_score = &amp;score;
    int (*p_arr)[3] = &amp;arr;           
    int (*fp_add)(int ,int )  = add;  //p_add是指向函数add的函数指针
    return 0;
}
</code></pre>
<p>特殊的情况，他们并不一定需要使用&amp;取地址：</p>
<ul>
<li>数组名的值就是这个数组的第一个元素的地址。</li>
<li>函数名的值就是这个函数的地址。</li>
<li>字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。</li>
</ul>
<pre><code class="language-c">int add(int a , int b){
    return a + b;
}
int main(void)
{
    int arr[3] = {1,2,3};
    //-----------------------
    int* p_first = arr;
    int (*fp_add)(int ,int )  =  add;
    const char* msg = &quot;Hello world&quot;;
    return 0;
}
</code></pre>
<p><strong>解地址</strong></p>
<p>我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个*号。</p>
<p>解指针的实质是：从指针指向的内存块中取出这个内存数据。</p>
<pre><code class="language-c">int main(void)
{
    int age = 19;
    int*p_age = &amp;age;
    *p_age  = 20;  //通过指针修改指向的内存数据

    printf(&quot;age = %d\n&quot;,*p_age);   //通过指针读取指向的内存数据
    printf(&quot;age = %d\n&quot;,age);

    return 0;
}
</code></pre>
<p><strong>指针之间的赋值</strong></p>
<p>指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。</p>
<pre><code class="language-c">int* p1  = &amp; num;
int* p3 = p1;

//通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://acoldfront.github.io//post-images/1584518724001.png" alt="" loading="lazy"></figure>
<p><strong>空指针</strong></p>
<p>指向空，或者说不指向任何东西。在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。</p>
<p>换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。</p>
<p>下面代码摘自 stddef.h</p>
<pre><code class="language-c">#ifdef __cplusplus
     #define NULL    0
#else    
     #define NULL    ((void *)0)
#endif
</code></pre>
<p><strong>坏指针</strong></p>
<p>指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。</p>
<p>任何一个指针变量在做 解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。</p>
<p>下面的代码就是错误的示例。</p>
<pre><code class="language-c">void opp()
{
     int*p = NULL;
     *p = 10;      //Oops! 不能对NULL解地址
}

void foo()
{
     int*p;
     *p = 10;      //Oops! 不能对一个未知的地址解地址
}

void bar()
{
     int*p = (int*)1000; 
     *p =10;      //Oops!   不能对一个可能不属于本程序的内存的地址的指针解地址
}
</code></pre>
<h2 id="指针的2个重要属性">指针的2个重要属性</h2>
<p>指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 指针的类型，指针的值。</p>
<pre><code class="language-c">int main(void)
{
    int num = 97;
    int *p1  = &amp;num;
    char* p2 = (char*)(&amp;num);

    printf(&quot;%d\n&quot;,*p1);    //输出  97
    putchar(*p2);          //输出  a
    return 0;
}
</code></pre>
<p>指针的值：很好理解，如上面的num 变量 ，其地址的值就是0028FF40 ，因此 p1的值就是0028FF40。数据的地址用于在内存中定位和标识这个数据，因为任何2个内存不重叠的不同数据的地址都是不同的。</p>
<p>指针的类型：指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息。一般指针变量的类型要和它指向的数据的类型匹配。</p>
<p>由于num的地址是0028FF40，因此p1  和  p2的值都是0028FF40</p>
<p>*p1  :  将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。</p>
<p>*p2  :  将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即'a'。</p>
<p>同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。</p>
<p><strong>void*类型指针</strong></p>
<p>由于void是空类型，因此void<em>类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void</em>类型的指针做解指针操作。</p>
<h2 id="结构体和指针">结构体和指针</h2>
<p>结构体指针有特殊的语法：  -&gt; 符号</p>
<p>如果p是一个结构体指针，则可以使用 p -&gt;【成员】 的方法访问结构体的成员。p-&gt;member 等价于 (*p).member。</p>
<pre><code class="language-c">typedef struct
{
    char name[31];
    int age;
    float score;
}Student;

int main(void)
{
    Student stu = {&quot;Bob&quot; , 19, 98.0};
    Student*ps = &amp;stu;

    ps-&gt;age = 20;
    ps-&gt;score = 99.0;
    printf(&quot;name:%s age:%d\n&quot;,ps-&gt;name,ps-&gt;age);
    return 0;
}
</code></pre>
<h2 id="数组和指针">数组和指针</h2>
<p>1、数组名作为右值的时候，就是第一个元素的地址。</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p_first = arr;
    printf(&quot;%d\n&quot;,*p_first);  //1
    return 0;
}
</code></pre>
<p>2、指向数组元素的指针 支持 递增 递减 运算。（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的）</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    for(;p!=arr+3;p++){
        printf(&quot;%d\n&quot;,*p); 
    }
    return 0;
}
</code></pre>
<p>3、p= p+1 意思是，让p指向原来指向的内存块的下一个相邻的相同类型的内存块。</p>
<p>同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。</p>
<p>4、p[n]    == *(p+n)<br>
p[n][m]  == *(  *(p+n)+ m )</p>
<p>5、当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。</p>
<p>这就是为什么我么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    printf(&quot;sizeof(arr)=%d\n&quot;,sizeof(arr));  //sizeof(arr)=12
    printf(&quot;sizeof(p)=%d\n&quot;,sizeof(p));   //sizeof(p)=4
 
    return 0;
}
</code></pre>
<h1 id="函数和指针">函数和指针</h1>
<p><strong>函数的参数和指针</strong></p>
<p>C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p>
<pre><code class="language-c">void change(int a)
{
    a++;      //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。
}
int main(void)
{
    int age = 19;
    change(age);
    printf(&quot;age = %d\n&quot;,age);   // age = 19
    return 0;
}
</code></pre>
<p>有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。</p>
<p>传递变量的指针可以轻松解决上述问题。</p>
<pre><code class="language-c">void change(int* pa)
{
    (*pa)++;   //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时，
               //会直接去内存中找到age这个数据，然后把它增1。
}
int main(void)
{
    int age = 19;
    change(&amp;age);
    printf(&quot;age = %d\n&quot;,age);   // age = 20
    return 0;
}
</code></pre>
<p>再来一个老生常谈的，用函数交换2个变量的值的例子：</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void swap_bad(int a,int b);
void swap_ok(int*pa,int*pb);

int main()
{
    int a = 5;
    int b = 3;
    swap_bad(a,b);       //Can`t swap;
    swap_ok(&amp;a,&amp;b);      //OK
    return 0;
}

//错误的写法
void swap_bad(int a,int b)
{
    int t;
    t=a;
    a=b;
    b=t;
}

//正确的写法：通过指针
void swap_ok(int*pa,int*pb)
{
    int t;
    t=*pa;
    *pa=*pb;
    *pb=t;
}
</code></pre>
<p><img src="https://acoldfront.github.io//post-images/1584518999545.png" alt="" loading="lazy"><br>
<img src="https://acoldfront.github.io//post-images/1584519009838.png" alt="" loading="lazy"><br>
有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象，相反，我们防止这个目标数据被改变。传递指针只是为了避免拷贝大型数据。<br>
考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。</p>
<pre><code class="language-c">typedef struct
{
    char name[31];
    int age;
    float score;
}Student;
//打印Student变量信息
void show(const Student * ps)
{
    printf(&quot;name:%s , age:%d , score:%.2f\n&quot;,ps-&gt;name,ps-&gt;age,ps-&gt;score);   
}
</code></pre>
<p>我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。另外我们为什么要使用指针而不是直接传递Student变量呢？</p>
<p>从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。</p>
<p><strong>函数的指针</strong></p>
<p>每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。既然是存放在内存中，那么函数也是有自己的指针的。</p>
<p>C语言中，函数名作为右值时，就是这个函数的指针。</p>
<pre><code class="language-c">void echo(const char *msg)
{
    printf(&quot;%s&quot;,msg);
}
int main(void)
{
    void(*p)(const char*) = echo;   //函数指针变量指向echo这个函数

    p(&quot;Hello &quot;);      //通过函数的指针p调用函数，等价于echo(&quot;Hello &quot;)
    echo(&quot;World\n&quot;);
    return 0;
}
</code></pre>
<h2 id="const-和-指针">const 和 指针</h2>
<p>const到底修饰谁？谁才是不变的？</p>
<p>下面是我总结的经验，分享一下。</p>
<p>如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型）</p>
<p>如果const后面就是一个数据，则直接修饰这个数据。</p>
<pre><code class="language-c">int main()
{
    int a = 1;
   
    int const *p1 = &amp;a;        //const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值
    const int*p2 =  &amp;a;        //const后面是int类型，则跳过int ，修饰*p2， 效果同上

    int* const p3 = NULL;      //const后面是数据p3。也就是指针p3本身是const .

    const int* const p4 = &amp;a;  // 通过p4不能改变a 的值，同时p4本身也是 const
    int const* const p5 = &amp;a;  //效果同上

    return 0;

}
</code></pre>
<pre><code class="language-c">typedef int* pint_t;  //将 int* 类型 包装为 pint_t,则pint_t 现在是一个完整的原子类型

int main()
{
   
    int a  = 1;
    const pint_t p1 = &amp;a;  //同样，const跳过类型pint_t，修饰p1，指针p1本身是const
    pint_t const p2 = &amp;a;  //const 直接修饰p，同上
   
    return 0;

}
</code></pre>
<h2 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h2>
<p>如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。<br>
<img src="https://acoldfront.github.io//post-images/1584519118077.png" alt="" loading="lazy"></p>
<h1 id="附加知识">附加知识</h1>
<p>指针和引用这个2个名词的区别。他们本质上来说是同样的东西。指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。引用是编程语言提供给程序员的抽象机制，而指针是操作系统提供给软件开发模型的抽象机制。</p>
<p>大端模式和小端模式</p>
<ol>
<li>Little-Endian就是低字节排放在内存的低地址端，高字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。</li>
<li>B i g-Endian就是高字节排放在内存的低地址端，低字节排放在内存的高地址端。</li>
</ol>
<p>采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。有些机器同时支持大端和小端模式。</p>
<p>假如 short类型占用2个字节，且存储的地址为0x30。<br>
short a = 1;</p>
<p>如下图：<br>
<img src="https://acoldfront.github.io//post-images/1584518079493.png" alt="" loading="lazy"></p>
<pre><code class="language-c">//测试机器使用的是否为小端模式。是，则返回true，否则返回false
//这个方法判别的依据就是：C语言中一个对象的地址就是这个对象占用的字节中，地址值最小的那个字节的地址。

bool isSmallIndain()
{
      unsigned int val = 'A';
      unsigned char* p = (unsigned char*)&amp;val;  //C/C++：对于多字节数据，取地址是取的数据对象的第一个字节的地址，也就是数据的低地址
      
      return *p == 'A';
}
</code></pre>
<p>作者：lulipro-代码钢琴家<br>
转载出处：<a href="http://www.cnblogs.com/lulipro/">http://www.cnblogs.com/lulipro/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔的图解递归算法 - C语言版]]></title>
        <id>https://acoldfront.github.io/post/TowersOfHanoiC/</id>
        <link href="https://acoldfront.github.io/post/TowersOfHanoiC/">
        </link>
        <updated>2020-03-18T05:53:42.000Z</updated>
        <content type="html"><![CDATA[<p>三个盘子的汉诺塔<br>
<img src="https://acoldfront.github.io//post-images/1584511104143.gif" alt="" loading="lazy"><br>
然后你移完发现左边柱子下面又蹦出来一个盘子<br>
<img src="https://acoldfront.github.io//post-images/1584511163698.gif" alt="" loading="lazy"><br>
好吧, 那就把中间的柱子看成目标柱<br>
<img src="https://acoldfront.github.io//post-images/1584511216776.gif" alt="" loading="lazy"></p>
<p>所以说一共就三步：<br>
把 n-1 号盘子移动到缓冲区<br>
把1号从起点移到终点<br>
然后把缓冲区的n-1号盘子也移到终点</p>
<p>写成C语言代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void f(char a, char b) {
    printf(&quot;从%c柱上往%c柱上挪动一个圆盘\n&quot;, a, b);
}

void g(int i, char a, char b, char c) {
    if (i == 2) {   //2块圆盘
        f(a, b);    //把a柱子上 最上面的一块    挪动到 b柱子上去 
        f(a, c);    //把a柱子上 最下面（最大）的那一块   挪动到 c柱子上去 
        f(b, c);     //把b柱子上 那一块   挪动到 c柱子上去 
    } else if (i &gt; 2) { //分成a柱子上的圆盘 两部分： ①第i块 圆盘和②i-i块 圆盘
        //i-i块 圆盘那一部分
        g(i - 1, a, c, b);  //把a柱子上的 i-1块 圆盘通过c柱子 挪动到 b柱子上去 
        //第i块 圆盘那一部分
        f(a, c);              //把a柱子上的 第i块（最大的那一块）挪动到 c柱子上去 
        //对于b柱子上的i-i块 圆盘那一部分进行再次递归 转移
        g(i - 1, b, a, c); //把b柱子上的 i-1块 圆盘通过a柱子 挪动到 c柱子上去 
    }
}

int main(void) {
    g(3, 'A', 'B', 'C');
    return 0;
}
</code></pre>
<p>运行结果：<br>
<img src="https://acoldfront.github.io//post-images/1584511340054.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔的图解递归算法 - Java版]]></title>
        <id>https://acoldfront.github.io/post/TowersOfHanoiJava/</id>
        <link href="https://acoldfront.github.io/post/TowersOfHanoiJava/">
        </link>
        <updated>2020-03-18T05:24:03.000Z</updated>
        <content type="html"><![CDATA[<p>一．起源：<br>
　　汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>二．抽象为数学问题：<br>
　　如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数<br>
<img src="https://acoldfront.github.io//post-images/1584509080986.jpg" alt="" loading="lazy"><br>
解：</p>
<pre><code>（1）n == 1
                第1次  1号盘  A----&gt;C       sum = 1 次
（2)  n == 2
                第1次  1号盘  A----&gt;B
                第2次  2号盘  A----&gt;C
                第3次  1号盘  B----&gt;C        sum = 3 次
（3）n == 3
                第1次  1号盘  A----&gt;C
                第2次  2号盘  A----&gt;B
                第3次  1号盘  C----&gt;B
                第4次  3号盘  A----&gt;C
                第5次  1号盘  B----&gt;A
                第6次  2号盘  B----&gt;C
                第7次  1号盘  A----&gt;C        sum = 7 次
</code></pre>
<p>不难发现规律：</p>
<pre><code>1个圆盘的次数 2的1次方减1
2个圆盘的次数 2的2次方减1
3个圆盘的次数 2的3次方减1
。  。   。    。   。 
n个圆盘的次数 2的n次方减1
</code></pre>
<p>故：移动次数为：2^n - 1</p>
<p>三．调用方法的栈机制:（特点：先进后出）<br>
从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p>
<p>四．算法分析（递归算法）：<br>
我们在利用计算机求汉诺塔问题时，必不可少的一步是对整个实现求解进行算法分析。到目前为止，求解汉诺塔问题最简单的算法还是同过递归来求，至于是什么是递归，递归实现的机制是什么，我们说的简单点就是自己是一个方法或者说是函数，但是在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。</p>
<p>实现这个算法可以简单分为三个步骤：<br>
　　　　（1）把n-1个盘子由A 移到 B；<br>
　　　　（2）把第n个盘子由 A移到 C；<br>
　　　　（3）把n-1个盘子由B 移到 C；</p>
<p>从这里入手，在加上上面数学问题解法的分析，我们不难发现，移到的步数必定为奇数步：<br>
　　　　（1）中间的一步是把最大的一个盘子由A移到C上去；<br>
　　　　（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上，<br>
　　　　（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；</p>
<p>五，java源代码：</p>
<pre><code class="language-java">package demo;
/**
 * 目的：实现汉诺塔问题求解
 * 作者：Crazer
 */
import java.util.Scanner;

public class TowersOfHanoi {
    static int m =0;//标记移动次数
    //实现移动的函数
    public static void move(int disks,char N,char M)
    {
        System.out.println(&quot;第&quot; + (++m) +&quot; 次移动 : &quot; +&quot; 把 &quot;+ disks+&quot; 号圆盘从 &quot; + N +&quot; -&gt;移到-&gt;  &quot; + M);
    }
    //递归实现汉诺塔的函数
    public static void hanoi(int n,char A,char B,char C)
    {
        if(n == 1)//圆盘只有一个时，只需将其从A塔移到C塔
            TowersOfHanoi.move(1, A, C);//将编b号为1的圆盘从A移到C
        else
        {//否则
            hanoi(n - 1, A, C, B);//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔
            TowersOfHanoi.move(n, A, C);//把A塔上编号为n的圆盘移到C上
            hanoi(n - 1, B, A, C);//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔
        }
    }
    public static void main(String[] args) {
        Scanner imput = new Scanner(System.in);
        char A = 'A';
        char B = 'B';
        char C = 'C';
        System.out.println(&quot;******************************************************************************************&quot;);
        System.out.println(&quot;这是汉诺塔问题（把A塔上编号从小号到大号的圆盘从A塔通过B辅助塔移动到C塔上去&quot;);
        System.out.println(&quot;******************************************************************************************&quot;);
        System.out.print(&quot;请输入圆盘的个数：&quot;);
        int disks = imput.nextInt();
        TowersOfHanoi.hanoi(disks, A, B, C);
        System.out.println(&quot;&gt;&gt;移动了&quot; + m + &quot;次，把A上的圆盘都移动到了C上&quot;);
        imput.close();
    }

}
</code></pre>
<p>六．图解程序运行流程：<br>
（1）函数hanoi(int n,char A,char B,char C)的功能是把编号为n的圆盘借助B从A移动到 C上。<br>
（2）函数move(int n ,char N ,char M)的功能是把1编号为n的圆盘从N 移到M上<br>
<img src="https://acoldfront.github.io//post-images/1584509457983.png" alt="" loading="lazy"></p>
<p>七．程序运行截图：<br>
<img src="https://acoldfront.github.io//post-images/1584510142328.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特殊极限lim(x→∞)(1+1/x)^x的证明]]></title>
        <id>https://acoldfront.github.io/post/teshujixian/</id>
        <link href="https://acoldfront.github.io/post/teshujixian/">
        </link>
        <updated>2020-03-17T09:44:51.000Z</updated>
        <content type="html"><![CDATA[<p>同济版《高等数学第七版》对该极限有如下证明：<br>
<img src="https://acoldfront.github.io//post-images/1584438325548.png" alt="" loading="lazy"><br>
而夹逼定理为下面的两个准则：<br>
<img src="https://acoldfront.github.io//post-images/1584438336590.png" alt="" loading="lazy"><br>
<img src="https://acoldfront.github.io//post-images/1584438357871.png" alt="" loading="lazy"><br>
根据以上两个准则对照书中的证明不难发现，书中证明中的夹逼定理运用情况并不与上面的两个准则十分相符，在证明中，更像是两个数列夹着一个函数，而准则中并没有指出两个数列夹着一个函数有所谓夹逼定理。那么这里究竟是如何运用夹逼定理的呢？</p>
<p>事实上，“设n&lt;=x&lt;n+1”就已经说明了证明中的看似数列的部分并非数列，而是特殊的函数，也就是说，这个n与自变量x相关，这使得不等式左右两边看似为数列的两个式子并不是完全是我们平时所理解的数列。这个n是[x]，也就是对x取整后的值，是实数x的函数而不是平时我们定义数列时所认为的正整数(虽然它们的取值都一样)。</p>
<p>所以或许用下面的表达方式更容易理解为什么这里能够运用夹逼定理：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>exp</mi><mo>⁡</mo><mo>(</mo><mo>−</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} \exp(-x) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>设n=[x]，则n&lt;=x&lt;n+1，故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo>]</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">[1+\frac{1}{2}]^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>]</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">[1+\frac{1}{x}]^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msup><mo>]</mo><mo>(</mo></msup><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{n}]^(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2329999999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]+1}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>)</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">(1+\frac{1}{x})^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，</p>
<p>设函数g(x)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>，函数h(x)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，则</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> =<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>  ，因n=[x]，则当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">{x \to \infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∞</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">{n \to \infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∞</span></span></span></span></span>，故运用复合函数的极限运算法则知，</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} [1+\frac{1}{(n+1)}]^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> =e</p>
<p>同理有<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msup><mo>]</mo><mo>(</mo></msup><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} [1+\frac{1}{n}]^(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2329999999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> = e，</p>
<p>故由准则I`知，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>]</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{x}]^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span> = e.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetBrains Quest 第二波活动的经历]]></title>
        <id>https://acoldfront.github.io/post/jetbrains-quest2/</id>
        <link href="https://acoldfront.github.io/post/jetbrains-quest2/">
        </link>
        <updated>2020-03-12T02:41:19.000Z</updated>
        <content type="html"><![CDATA[<p>https://twitter.com/jetbrains/status/1237694815283879943</p>
<p><code>.spleh A+lrtC/dmC .thgis fo tuo si ti semitemos ,etihw si txet nehw sa drah kooL .tseretni wohs dluohs uoy ecalp a si ,dessecorp si xat hctuD erehw esac ehT .sedih tseuq fo txen eht erehw si ,deificeps era segaugnal cificeps-niamod tcudorp ehT</code></p>
<p>翻过来就是</p>
<p><code>The product domain-specific languages are specified, is where the next of quest hides. The case where Dutch tax is processed, is a place you should show interest. Look hard as when text is white, sometimes it is out of sight. Cmd/Ctrl+A helps.</code></p>
<p>然后根据product domain-specific languages打开 https://www.jetbrains.com/mps/ 页面， 查找Dutch tax,点击Read MPS case study打开 PDF 文件，在 PDF 的右上角有隐藏的文字</p>
<p><code>This is our 20th year as a company,we have shared numbers in our JetBrains Annual report, sharing the section with 18,650 numbers will progress your quest.</code></p>
<p>打开20周年年报页面 https://www.jetbrains.com/company/annualreport/2019/，找到7th Annual Hackathon 部分，那些数字加起来就是 PDF 上面写的 18,650。点击分享可以看到信息：</p>
<p><code>I have found the JetBrains Quest! Sometimes you just need to look closely at the Haskell language,Hello,World! in the hackathon lego brainstorms project https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/</code></p>
<p>打开 lego brainstorms 部分，图片上有文字，查看图片alt可以看到：</p>
<p><code>d1D j00 kN0w J378r41n2 12 4lW4Y2 H1R1N9? ch3CK 0u7 73h K4r33r2 P493 4nD 533 1f 7H3r3 12 4 J08 F0r J00 0R 4 KW357 cH4LL3n93 70 90 fUr7h3r @ l3457.</code></p>
<p>翻译为：</p>
<p><code>Did you know Jetbrains is always hiring? Check out the kareers page and see if there is a job for you or for kwest challenge to go further atleast.</code></p>
<p>打开 https://www.jetbrains.com/jobs/</p>
<p>在求职页面选择三个 Any 就会有这个页面得链接</p>
<p>https://www.jetbrains.com/careers/jobs/fearless-quester-356/</p>
<p>页面上有这些字</p>
<p><code>To progress with your quest what you’ll need:. To check out what we have for game developers. . Be geeky enough to remember how you used to cheat at Konami games. . Try cheating on the page.</code></p>
<p>根据提示打开 https://www.jetbrains.com/gamedev/</p>
<p>在页面上输入科乐美秘技就是 ↑↑↓↓←→←→BA 就会打开一个游戏，打碎砖块就可以看到终点了。</p>
<!-- 兑换码：GamesAreFun-->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次参与 JetBrains Quest 活动的经历]]></title>
        <id>https://acoldfront.github.io/post/jetbrains-quest1/</id>
        <link href="https://acoldfront.github.io/post/jetbrains-quest1/">
        </link>
        <updated>2020-03-12T02:15:52.000Z</updated>
        <content type="html"><![CDATA[<p>JetBrains 公司是干啥的自然不用我多说，无意中得知 JetBrains Quest 活动的消息，就也手痒的参与了一把。题目不难，一步步探索、揭晓谜底的过程还是挺有趣的，在这里简单记录一下本次解谜的过程。</p>
<p><strong>注：</strong> 最后到手的奖励是三个月的全产品订阅，不得不说 JetBrains 在优惠活动方面从来没让人失望过。</p>
<h2 id="第一步读懂题目">第一步，读懂题目</h2>
<p>先来看看 JetBrains 发布活动消息的这则推文：<img src="https://acoldfront.github.io//post-images/1583980379053.png" alt="JetBrains Quest活动消息的推文" loading="lazy"></p>
<p>从中我们得到了如下的一串字符：</p>
<p><code>48 61 76 65 20 79 6f 75 20 73 65 65 6e 20 74 68 65 20 73 6f 75 72 63 65 20 63 6f 64 65 20 6f 66 20 74 68 65 20 4a 65 74 42 72 61 69 6e 73 20 77 65 62 73 69 74 65 3f</code></p>
<p>观察发现，字符串中同时包含数字和字母，但是字母最大只有 <code>f</code> （按 a 最小，z 最大排序），这是很明显的 16 进制字符串的特征。</p>
<p>尝试一下把上面每个数字按 16 进制转成 10 进制，然后再根据 ASCII 码表取出对应的字符（肯定是写个脚本来自动转换啦），我们得到了如下的一句话：<code>Have you seen the source code of the JetBrains website?</code> 。嗯，让我们看看 JetBrains 网站的源码，那就来看看呗。</p>
<h2 id="第二步源码中的信息">第二步，源码中的信息</h2>
<p>打开 https://www.jetbrains.com/ ，右键查看网页源码，用鼠标拉动滑块快速的扫过去，很快发现在第400行附近有如下的一段注释：</p>
<pre><code class="language-html">   O
{o)xxx|===============-
      O

Welcome to the JetBrains Quest.

What awaits ahead is a series of challenges. Each one will require a little initiative, a little thinking, and a whole lot of JetBrains to get to the end. Cheating is allowed and in some places encouraged. You have until the 15th of March at 12:00 CET to finish all the quests.
Getting to the end of each quest will earn you a reward.
Let the quest commence!

JetBrains has a lot of products, but there is one that looks like a joke on our Products page, you should start there... (hint: use Chrome Incognito mode)
It’s dangerous to go alone take this key: Good luck! == Jrrg#oxfn$

                 O
-===============|xxx(o}
                 O
</code></pre>
<p>这里给出了活动截止时间等信息，还有一条下一步的提示 —— 产品页面有一个看起来像玩笑的应用，我们需要从那里开始（提示：使用 Chrome 隐身模式）。</p>
<h2 id="第三步奇怪的应用">第三步，奇怪的应用</h2>
<p>根据上一步的提示，我们来到产品页面：https://www.jetbrains.com/products.html</p>
<p>凭着对 JetBrains 产品的印象和大胆猜测，很快锁定了那个看起来像开玩笑的应用：<br>
<img src="https://acoldfront.github.io//post-images/1583980435076.jpg" alt="JetBrains Quest线索" loading="lazy"></p>
<p>点击 <code>Learn more</code> ，页面上弹出了一个窗口，内容如下：</p>
<pre><code class="language-html">You have discovered our JetBrains Quest! If you don’t know what this is, you should start from Twitter, Facebook or LinkedIn.


To continue to the next challenge you need to go to the following link… But there is a problem, the last 3 digits are missing:


https://jb.gg/###


To get these digits you need to know how many prime numbers there are between 500 and 5000


Good Luck!
</code></pre>
<p>很明显，我们找对了地方，并再次获得了下一步的提示 —— 一个残缺的链接，后面三位是 500 到 5000 内素数的个数。</p>
<h2 id="第四步素数的个数">第四步，素数的个数</h2>
<p>根据上一步的提示，我们随便撸一段脚本计算一下 500 到 5000 内素数的个数，发现结果是 574，于是我们访问链接 https://jb.gg/574 进入下一步。</p>
<p>页面最终跳转到了 https://www.jetbrains.com/help/pycharm/getting-help.html#quest ，这次给了一张图片作为提示。注意到了图片上的如下部分：<img src="https://acoldfront.github.io//post-images/1583980459022.png" alt="JetBrains Quest线索" loading="lazy"></p>
<p>那个“YT”的标志是 JetBrains 的产品 YouTrack，另外，对 JetBrains 稍微了解深入一点的人应该能意识到“MPS-31816”是一个 Issues 号。根据这些信息，配合搜索引擎，我们找到了如下页面：https://youtrack.jetbrains.com/issue/MPS-31816 。下面是页面上所给出的信息：</p>
<pre><code>“The key is to think back to the beginning.” -- The JetBrains Quest team

Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh/#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw/#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul}h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul}h1#kwwsv=22zzz1mhweudlqv1frp2surpr2txhvw2
</code></pre>
<p>至此，我们得到了一长串的奇怪字符串外加一句话 —— 关键是要回过头去思考。</p>
<h2 id="第五步早已给出的提示">第五步，早已给出的提示</h2>
<p>有没有觉得上面那些字符排列的方式有点眼熟？没错，还记得我们在第二步拿到的线索吗？还有一句话没用上。</p>
<pre><code>It’s dangerous to go alone take this key: Good luck! == Jrrg#oxfn$
</code></pre>
<p>最后这个 <code>Jrrg#oxfn$</code> 跟上面的字符串是不是有点同出一辙的感觉，再结合提示信息“回过头去思考”，我们这不就是回头来寻找线索吗？基本能够确定这一句话就是关键。</p>
<p>我们来简单分析一下，最先注意到的就是 <code>==</code> ，这是编程语言中的“等于”，提醒我们 <code>Good luck!</code> 和 <code>Jrrg#oxfn$</code> 相等；数一下两者字符的个数，发现都是 10 个（包括空格）；再注意到相同字符变换后对应的字符不变（前者两个连续的 <code>o</code> 在后者中就对应两个连续的 <code>r</code> ）。</p>
<p>基于上面这些分析，大胆猜测这是某种基于单个字符的加密方式，再配合一点直觉和实际的操作尝试，嗯，很典型的凯撒密码。简单来说，这里所用的加密操作就是将每个字符在 ASCII 码表中的值 +3，再取出新的值对应的字符。</p>
<p>知道了这一点之后再去解密上面的长字符串就很简单了，反过来将每个字符的 ASCII 值减 3 ，然后取出对应的字符，下面是最终解密出来的信息：</p>
<pre><code>Nice! If you are reading this you must have worked out how to decrypt it. This is our issue tracker designed for agile teams. It is free for up to 3 users in Cloud and for 10 users in Standalone, so if you want to give it a go in your team then we totally recommend it. you have finished the first Quest, now it’s time to redeem your first prize. The code for the first quest is “TheDriveToDevelop”. Go to the Quest Page and use the code to claim your prize. https://www.jetbrains.com/promo/quest/
</code></pre>
<p>根据该信息，我们已经成功完成了本次 <code>JetBrains Quest</code> 的所有流程（这只是第一个 Quest ，后续还有其他挑战）。</p>
<h2 id="第六步兑奖">第六步，兑奖</h2>
<p>接下来就就可以去领取奖励啦：打开 https://www.jetbrains.com/promo/quest/ ，输入你的邮箱和解密信息中的 Code：<code>TheDriveToDevelop</code> ，<br>
<img src="https://acoldfront.github.io//post-images/1583980484262.png" alt="JetBrains Quest奖励发放邮件" loading="lazy"><br>
稍等一会儿就会收到一封包含 3 个月全产品订阅兑换码的邮件，下面是我收到邮件的部分截图：<img src="https://acoldfront.github.io//post-images/1583980500131.jpg" alt="JetBrains Quest奖励发放邮件" loading="lazy"><br>
点击蓝色的 <strong>HOW TO REDEEM THE CODE</strong><img src="https://acoldfront.github.io//post-images/1583980661028.png" alt="JetBrains Quest奖励发放邮件" loading="lazy"><br>
输入上面的密钥，你的名字，姓氏，邮箱，国家/地区。然后点提交。<br>
然后再等2分钟左右，又收到一封邮件<br>
让你点击其中的链接激活账号<img src="https://acoldfront.github.io//post-images/1583980567631.png" alt="JetBrains Quest奖励发放邮件" loading="lazy"><br>
让你输入名字，姓氏，用户名，密码。点击提交。<img src="https://acoldfront.github.io//post-images/1583980580622.jpg" alt="JetBrains Quest奖励发放邮件" loading="lazy"><br>
打开IDEA验证，输入刚刚注册的账号密码。延长到了6月11日。<br>
<img src="https://acoldfront.github.io//post-images/1583980591767.jpg" alt="验证" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MobaXterm 20.0 汉化专业版]]></title>
        <id>https://acoldfront.github.io/post/mobaxterm/</id>
        <link href="https://acoldfront.github.io/post/mobaxterm/">
        </link>
        <updated>2020-03-04T07:51:32.000Z</updated>
        <summary type="html"><![CDATA[<p>MobaXterm X服务器和SSH客户端MobaXterm是您远程计算的终极工具箱。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MobaXterm X服务器和SSH客户端MobaXterm是您远程计算的终极工具箱。</p>
<!-- more -->
<p>在单个Windows应用程序中，它提供了大量功能，这些功能是为程序员，网站管理员，IT管理员以及需要以更简单的方式处理远程作业的所有用户量身定制的。MobaXterm向Windows桌面提供所有重要的远程网络工具（SSH，X11，RDP，VNC，FTP，MOSH ……）和Unix命令（bash，ls，cat，sed，grep，awk，rsync等） ，在一个开箱即用的单个便携式exe文件中。为您的远程任务提供一体化网络应用程序有很多优点，当您使用SSH连接到远程服务器时，将自动弹出图形SFTP浏览器以直接编辑您的远程文件。您的远程应用程序也将使用嵌入式X服务器在Windows桌面上无缝显示。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>Crazer汉化破解<br>
<img src="https://acoldfront.github.io//post-images/1583308533242.png" alt="" loading="lazy"></p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p>在本文寻找！Good luck！😏</p>
<!-- 链接: https://pan.baidu.com/s/15pOMNeZhVx1pmklYLswPBg 提取码: qg3i-->
]]></content>
    </entry>
</feed>