<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-04-09T00:44:57.951Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[思维导图软件 XMind ZEN 2020 v10.1.2 全平台 完美破解版]]></title>
        <id>https://acoldfront.github.io/post/xmind-zen-2020/</id>
        <link href="https://acoldfront.github.io/post/xmind-zen-2020/">
        </link>
        <updated>2020-04-07T22:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
<!-- more -->
<p>XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。</p>
<p>这两年思维导图突然就火起来了，各种思维导图软件也是雨后春笋般冒出来了，自 Xmind 发布以来就受到全球多个国家的办公一族喜爱。而 XMind 开发团队成员也在不断的去改进产品以提供优秀的生产力工具和服务，帮助人们节省时间并提升效率为目标。<br>
<img src="https://acoldfront.github.io//post-images/1579860380835.png" alt="" loading="lazy"></p>
<p>全新内核，经典 XMind 体验。<br>
我们努力了3年，100% 重写了思维导图引擎的每一个细节，XMind: ZEN 对 XMind 8 做到了完全兼容，让你有一种全新却不失经典的体验。</p>
<p>无人可超越，只有超越自己。<br>
对所有主题进行了重新设计，为您的每一张导图都注入新的活力。字体渲染也得到了极大的改进，让每一张思维导图既美观又专业。</p>
<p>我们专注，为了让您更专注。<br>
ZEN 模式，寓意为禅。让专注变成一种习惯。</p>
<p>全新 Snowbrush 引擎<br>
我们努力了3年，100% 重写了思维导图的引擎，着眼在未来的黑科技上，提升了思维导图的展示效果，丰富了绘图的元素。</p>
<p>充满惊喜的主题<br>
XMind: ZEN 对所有主题进行了重新设计，为您的每一张导图都注入新的活力，专业的同时又不失丰富元素，好看到让人羡慕。</p>
<p>Font Rendering<br>
由于极大地改进了字体的渲染技术，无论你用 Mac 还是 Windows 创建思维导图，所有文字都以同一样式清晰呈现。XMind: ZEN 精选多款优质字体，爱上编辑导图，从未如此简单。</p>
<p>Markdown<br>
我们相信 Markdown 会为你带来更好的使用体验，将做好的图导出为 Markdown 格式后，会让你更易于阅读。</p>
<p>集专注于 ZEN 模式<br>
ZEN 模式，寓意为禅，让专注变成一种习惯。进入 ZEN 模式，隐藏页面内多余的元素，帮助你全神贯注地绘制每一个主题，心无旁骛地完成工作。</p>
<p>贴纸，原创的更好<br>
设计师原创的贴纸，每一个都精心绘制，更准确地满足你的需求，精彩无处不在。</p>
<p>100% 对 XMind 8 兼容<br>
XMind: ZEN 对 XMind 8 做到了完全兼容，所有 XMind 8 拥有的图形结构，在 XMind: ZEN 中都能完美展现。</p>
<p>导出PDF和印象笔记<br>
将思维导图导出为矢量的 PDF 文件，方便您将导图随意放大和清晰地打印。印象笔记的粉丝们还会惊喜地发现只需简单地点击，便可将导图分享到印象笔记中。</p>
<h2 id="更新日志">###更新日志</h2>
<p>10.1.1</p>
<p>Xmind ZEN更名为Xmind 2020</p>
<ol>
<li>修复了旧版本升级后，启动时可能报错的问题；</li>
<li>修复了 Windows 下可能无法检测到部分字体的问题；</li>
<li>修复了改变字体大小时，可能影响到其他主题的问题；</li>
<li>修复了编辑方程后，画布可能卡住的问题；</li>
<li>修复了输入空方程时会报错的问题；</li>
<li>修复了部分其他已知问题。</li>
</ol>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于官网最新版本破解</p>
<p>破解授权，移除验证，去除试用提示</p>
<p>能正常导出图片无水印，PDF无水印，导出word，粘贴图片等高级功能</p>
<p>v2版本导出PNG缩放大小已修复</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>将app.asar放入XMind-ZEN安装目录的resources文件夹下替换</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/175dlcFsxq9RsiB_BGt0erw">链接: https://pan.baidu.com/s/175dlcFsxq9RsiB_BGt0erw 提取码: 8kh4</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android VSCO v158 破解版]]></title>
        <id>https://acoldfront.github.io/post/vsco/</id>
        <link href="https://acoldfront.github.io/post/vsco/">
        </link>
        <updated>2020-04-06T10:17:57.000Z</updated>
        <summary type="html"><![CDATA[<p>VSCO是时下一款非常流行的摄影App。VSCO支持的功能包括摄影App，语音通讯、相机拍照、照片编辑和照片分享等功能。但是其核心还是滤镜非常强大！</p>
]]></summary>
        <content type="html"><![CDATA[<p>VSCO是时下一款非常流行的摄影App。VSCO支持的功能包括摄影App，语音通讯、相机拍照、照片编辑和照片分享等功能。但是其核心还是滤镜非常强大！</p>
<!-- more -->
<p>随着版本的不断升级，VSCO 逐渐成了一款功能强大的摄影App，包含了相机拍照、照片编辑和照片分享三大功能。虽如此，但VSCO依然保持了简单的使用方式(对于已上手用户而言使用非常简单)，可以利用VSCO内置包含了强大手动控制功能的相机进行拍摄，也可以利用VSCO内数量众多的胶片滤镜、照片基础调整工具对照片进行处理，创造出令人着迷、胶片味道十足的手机摄影作品。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>破解会员，解锁全部滤镜</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1jQyZyfgmDLCubXhswtD77g">链接: https://pan.baidu.com/s/1jQyZyfgmDLCubXhswtD77g 提取码: r7sg </a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WinSnap v5.2.3 便携破解版]]></title>
        <id>https://acoldfront.github.io/post/winsnap/</id>
        <link href="https://acoldfront.github.io/post/winsnap/">
        </link>
        <updated>2020-04-05T03:17:37.000Z</updated>
        <summary type="html"><![CDATA[<p>WinSnap是一款屏幕捕获软件，能够让您得心应手地捕获到需要的屏幕截图。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WinSnap是一款屏幕捕获软件，能够让您得心应手地捕获到需要的屏幕截图。</p>
<!-- more -->
<p>捕捉图像方式灵活，主要可以捕捉整个屏幕、活动窗口、选定区域等，图像输出方式多样，主要包括文件、剪贴板、和邮件。软件具有设置捕捉前延时、自定义捕捉热键、图像文件自动按时间或模板命名、捕捉成功声音提示、预览捕捉图片、图像打印、图像水印、图像反色、图像翻转、图像旋转等功能。<br>
WinSnap轻巧、快速、简单、友好提供截图和图像编辑功能。和其它截图软件相比其最大亮点在于WinSnap可以捕获或去除Winodws 7的 Aero玻璃效果。WinSnap内置了阴影，反射，旋转，水印等效果，支持各种图像格式，并支持自动保存。</p>
<p><strong>WinSnap 主要特点：</strong><br>
[+]灵活的屏幕捕捉功能<br>
[+]内置图像编辑器：箭头，矩形，文本注释<br>
[+]设计用于捕获 Windows Aero 的干净背景<br>
[+]支持透明度的 PNG 和 TIFF 图像格式<br>
[+]高级自动保存和自动复制选项<br>
[+]常规键盘和鼠标控制（打印屏幕更换）<br>
[+]可配置工具菜单中打开外部图像编辑器<br>
[+]小和快速的图像编辑器，比画图更小<br>
[+]多语言用户界面（基于Unicode）<br>
<img src="https://acoldfront.github.io//post-images/1586056964047.png" alt="" loading="lazy"></p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>便携版制作</p>
<p>强制破解免授权，无需许可证密钥，截图保存无水印</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>若出现：从服务器返回了一个参照<br>
对着程序，右键，属性，兼容性，勾选以管理员身份运行。</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1AVppD7OUoGqk3n5sOl9cDA">链接: https://pan.baidu.com/s/1AVppD7OUoGqk3n5sOl9cDA 提取码: 241q</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WinRAR v5.90 Final 便携版]]></title>
        <id>https://acoldfront.github.io/post/winrar/</id>
        <link href="https://acoldfront.github.io/post/winrar/">
        </link>
        <updated>2020-04-01T10:40:15.000Z</updated>
        <summary type="html"><![CDATA[<p>WinRAR是一款功能强大的压缩包管理器，它是档案工具RAR在 Windows环境下的图形界面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WinRAR是一款功能强大的压缩包管理器，它是档案工具RAR在 Windows环境下的图形界面。</p>
<!-- more -->
<p>WinRAR可用于备份数据，缩减电子邮件附件的大小，解压缩从 Internet 上下载的RAR、ZIP及其它类型文件，WinRAR并且可以新建 RAR 及 ZIP 格式等的压缩类文件。WinRAR非常实用、方便，中文化工作更为完善，WinRAR包括主工作界面、右键菜单，甚至连十万字的 .hlp 在线帮助文件、使用手册文件、Readme 文件都完全是中文内容。</p>
<p><strong>WinRAR软件特点</strong></p>
<p>1、压缩率更高</p>
<p>WinRAR 在 DOS 时代就一直具备这种优势，经过多次试验证明，WinRAR 的 RAR 格式一般要比其他的 ZIP 格式高出 10%～30% 的压缩率，尤其是它还提供了可选择的、针对多媒体数据的压缩算法。</p>
<p>2、对多媒体文件有独特的高压缩率算法</p>
<p>WinRAR 对 WAV、BMP 声音及图像文件可以用独特的多媒体压缩算法大大提高压缩率，虽然我们可以将 WAV、BMP 文件转为 MP3．JPG 等格式节省存储空间，但不要忘记 WinRAR 的压缩可是标准的无损压缩。</p>
<p>3、能完善地支持ZIP格式并且可以解压多种格式的压缩包</p>
<p>虽然其他软件也能支持 ARJ、LHA 等格式，但却需要外挂对应软件的 DOS 版本，实在是功能有限。但WinRAR就不同了，不但能解压多数压缩格式，且不需外挂程序支持就可直接建立 ZIP 格式的压缩文件，所以我们不必担心离开了其他软件如何处理 ZIP 格式的问题。</p>
<p>4、设置项目非常完善，并且可以定制界面</p>
<p>通过开始选单的程序组启动WinRAR，在其主界面中选择“选项”选单下的“设置”打开设置窗口，分为常规、压缩、路径、文件列表、查看器、综合六大类，非常丰富，通过修改它们，可以更好地使用 WinRAR。实战：如果同时安装了某款压缩软件与 WinRAR，ZIP 文件的关联经常发生混乱，一般我们只需进入设置窗口，选“综合”标签，将“ WinRAR 关联文件”一栏中的 ZIP 一项打勾，确定后就可使 ZIP 文件与 WinRAR 关联，反之如果将勾去掉，则 WinRAR 自动修改注册表使 ZIP 重新与这个压缩软件的关联。</p>
<p>5、对受损压缩文件的修复能力极强</p>
<p>在网上下载的ZIP、RAR类的文件往往因头部受损的问题导致不能打开，而用WinRAR调入后，只须单击界面中的“修复”按钮就可轻松修复，成功率极高。</p>
<p>6、可以不必解压就可查看压缩包信息</p>
<p>使用WinRAR，选中文件点击信息就可查看压缩包信息。</p>
<p>7、辅助功能设置细致</p>
<p>WinRAR可以在压缩窗口的“备份”标签中设置压缩前删除目标盘文件；可在压缩前单击“估计”按钮对压缩先评估一下；可以为压缩包加注释；可以设置压缩包的防受损功能，等等细微之处也能看出WinRAR的体贴周到。</p>
<p>8、压缩包可以锁住</p>
<p>使用WinRAR双击进入压缩包后，单击命令选单下的“锁定压缩包”就可防止人为的添加、删除等操作，保持压缩包的原始状态。</p>
<p>9、压缩包可以看隐藏文件</p>
<p>你还在为Autorun病毒发愁？Winrar就提供了“透视”功能。把那些隐藏属性的文件一目了然。<br>
<img src="https://acoldfront.github.io//post-images/1585737802815.png" alt="" loading="lazy"></p>
<h3 id="更新日志">更新日志</h3>
<hr>
<p>1.对于具有16个或更多内核的CPU，RAR压缩速度得到了提高。<br>
2.对于创建高度可压缩的数据类型，“快速”方法（等效于-m1命令行）在创建RAR5归档文件时可以实现较高的压缩率。<br>
3.使用的最大线程数从32增加到64。命令行-mt <threads>开关接受从1到64的值。<br>
4. WinRAR设置的“常规”页面上的“多线程”参数将替换为“线程”输入字段，您可以在其中指定所需的CPU线程数。取值范围是1到最大可用逻辑CPU单元数。<br>
5. WinRAR在浏览档案内容时显示打包和解压缩的文件夹大小。<br>
6.“总文件夹”字段添加到WinRAR“信息”命令显示的归档参数列表中。<br>
Windows资源管理器中存档属性中的“存档”页面添加了相同的字段。<br>
7.如果读取存档内容花费的时间很长，则会显示一个包含进度条和“取消”按钮的窗口。它对于访问内容速度较慢的存档格式很有用，例如大型的基于TAR的存档（例如.tar.gz和tar.bz2）<br>
8.可以调整归档和提取进度窗口的大小，也可以调整其他一些命令的进度窗口的大小。<br>
9.改进了具有恢复记录且无数据移位的RAR5档案的“修复”性能。<br>
它在WinRAR 5.80中恶化，现在恢复到原始水平。<br>
10.对具有加密文件名的RAR5归档文件执行基于恢复记录的修复时，不会发出密码提示。可以在不提供密码的情况下执行此命令。<br>
11.如果“转换档案”命令中没有用于转换档案的文件夹，则WinRAR尝试创建该文件夹。<br>
以前的版本无法在不存在的目标文件夹中创建转换后的归档。<br>
12.添加了对GZIP存档的提取支持，并带有可选的标头校验和字段。<br>
13.修复的错误：<br>
a）在处理具有有效恢复记录的归档文件时，“修复”命令可能会错误地显示“恢复记录已损坏”消息。<br>
此消息并未阻止进一步的修复操作；<br>
b）如果默认压缩配置文件中的“快速打开信息”选项设置为“不添加”，并且此配置文件是通过某些命令或对话框加载的，则WinRAR在浏览RAR归档文件的内容时会忽略快速打开信息。<br>
例如，它是在打开存档或密码对话框之后发生的；<br>
c）Ctrl + C“复制”快捷键在存档注释窗口中不起作用；<br>
d）如果设置了“将每个文件放入单独的存档”和“在子文件夹中存档”选项，则WinRAR将忽略在存档名称字段中指定的目标路径。</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>官方版集成许可</p>
<p>便携版制作，集成x64和x86版本</p>
<p>能够关联文件</p>
<p>集成无限制许可文件</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1wDn8z5MBKJKyXgiJk7DwHg">链接: https://pan.baidu.com/s/1wDn8z5MBKJKyXgiJk7DwHg 提取码: 1b4r</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库管理工具 PremiumSoft Navicat Premium v15.0.12 中文特别版]]></title>
        <id>https://acoldfront.github.io/post/navicat-premium/</id>
        <link href="https://acoldfront.github.io/post/navicat-premium/">
        </link>
        <updated>2020-03-23T04:55:18.000Z</updated>
        <summary type="html"><![CDATA[<p>Navicat premium是一款数据库管理工具。将此工具连接数据库，你可以从中看到各种数据库的详细信息。包括报错，等等。当然，你也可以通过他，登陆数据库，进行各种操作。Navicat Premium是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Navicat premium是一款数据库管理工具。将此工具连接数据库，你可以从中看到各种数据库的详细信息。包括报错，等等。当然，你也可以通过他，登陆数据库，进行各种操作。Navicat Premium是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p>
<!-- more -->
<p>Navicat Premium结合了其他Navicat成员的功能。有了这种连线到不同资料库类型的能力，Navicat Premium支持在 MySQL、SQLite、Oracle 及 PostgreSQL 之间传输资料。它支持大部分的 MySQL、SQLite、Oracle 及 PostgreSQL 功能，包括预存程序、事件、触发器、函式、检视等。<br>
Navicat Premium可以让你简单并快速的在多种资料库系统间传输资料，或传输一份以SQL格式及编码设计的纯文字档。<br>
不同的资料库的批次处理任务也可以设定排程并在指定的时间执行。其他功能包括汇入/汇出精灵、查询建立工具、报表产生器、资料同步、备份、工作排程及更多。</p>
<p>Navicat的的功能足以提供专业开发人员的所有需求，但是对资料库伺服器的新手来说又相当容易学习。<br>
Navicat Premium [2] 有三种平台版本- Microsoft Windows、Mac OS X及Linux。它可以让使用者连接本地/远端伺服器、提供一些实用的工具如资料/结构同步、汇入/汇出、备份/回复及报表以协助管理资料的流程。</p>
<p>Navicat Premium(导航猫数据库管理)是一个可多重连线资料库的管理工具，Navicat Premium(导航猫数据库管理)可以让你以单一程式同时连线到MySQL、SQLite、Oracle 及 PostgreSQL资料库，让管理不同类型的资料库更加的方便。 　Navicat Premium可以让你简单并快速的在多种资料库系统间传输资料，或传输一份以SQL格式及编码设计的纯文字档。</p>
<p>不同的资料库的批次处理任务也可以设定排程并在指定的时间执行。其他功能包括汇入/汇出精灵、查询建立工具、报表产生器、资料同步、备份、工作排程及更多。</p>
<p>Navicat的的功能足以提供专业开发人员的所有需求，但是对资料库伺服器的新手来说又相当容易学习。<br>
<img src="https://acoldfront.github.io//post-images/1580014704119.png" alt="" loading="lazy"></p>
<p>Navicat Cloud<br>
Navicat 提供 Navicat Cloud 服务给用户。同步你的连接设置、模型、查询和虚拟组到云。这样你就能随时随地实时访问他们。有了 Navicat Cloud，你可以善用一天中的每分每秒，以最大限度提高你的工作效率。了解更多›</p>
<p>安全连接<br>
Navicat 可以让你通过 SSH 通道创建安全的 SSH 阶段作业，确保两台主机之间的连接受到强大验证和安全加密的保护。验证方式可使用密码或公钥和私钥对。Navicat 亦支持 HTTP 通道，让你灵活地绕过限制直接数据库服务器连接的互联网服务供应商。</p>
<p>对象设计器<br>
使用专业的对象设计器创建、修改和设计所有数据库对象，例如：表、视图、函数、过程、索引、触发器和序列。无需编写复杂的 SQL 来创建和编辑对象，你会知道你正使用什么选项。</p>
<p>表查看器<br>
网格或表单查看<br>
使用网格查看添加、修改和删除记录。用类似数据表的功能浏览网格查看，例如排序和隐藏数据组，使用我们的助理编辑器：备注、十六进制、图像或更多</p>
<p>你也可以用表单查看操作记录。清楚显示记录的字段名和其值，不必担心误解数据。</p>
<p>外键数据选择<br>
在你的数据库使用外键关系锚定参考的查找表，并自动建立下拉列表。无需持续对照参考主表，你可以简化你的工作流程和提升效率。<br>
SQL 创建工具或编辑器</p>
<p>SQL 创建工具<br>
视觉化 SQL 创建工具让你创建和编辑查询或视图，而不必担心语法和正确命令的用法。选择你想在表中执行的操作，它会为你编写 SQL 语句。</p>
<p>自动完成代码<br>
使用我们的自动完成代码功能，能快速地在 SQL 编辑器中创建 SQL 语句。无论你想选择的是数据库对象的属性或 SQL关键字，你只需从下拉列表中选择。</p>
<p>数据库设计器<br>
逆向工程<br>
使用 Navicat 的逆向工程，你可以从一个现有的数据库创建数据库模型，可视化地显现和编辑你的数据库结构或创建一个图形模型，并由模型生成一个数据库。</p>
<p>正向工程和脚本生成<br>
同步到数据库功能给你充分了解所有数据库的差异。生成必要的同步脚本来更新目标数据库，并使其与模型相同。</p>
<p>导出 SQL 让你有机会全面控制最终的 SQL 脚本，生成参照完整性规则，生成模型的独立部份、注释、字符集等。它可以节省你的工作时间。</p>
<p>PL/SQL 代码调试器<br>
PL/SQLPL/PGSQL<br>
PL/SQL 调试器提供的功能，如设置断点，步进通过程序，查看和修改变量值，及查看调用堆栈。你可以直接从 Navicat 的工作区中调试 PL/SQL 代码如过程和函数、对象方法和触发器。</p>
<p>数据处理工具<br>
导入或导出向导<br>
从不同格式的文件导入数据到表，例如 Access、Excel、XML、TXT、CSV、JSON 及更多。而且，在设置数据源连接后，你可以从 ODBC 导入数据。只需简单地选择你要导入的表，或使用添加查询按钮指定查询。同样，你可以将数据导出到各种格式，如 Excel、TXT、CSV、DBF、XML 等。</p>
<p>数据传输<br>
在多个不同的数据库系统间轻松地传输数据 – MySQL、MariaDB、SQL Server、Oracle、PostgreSQL 和 SQLite 数据库。你可以选择以指定的 SQL 格式和编码导出数据为 SQL 文件。这个功能可大大的简化迁移数据的进程。</p>
<p>数据或结构同步<br>
从一个数据库中以详细的分析进程传输数据到另外一个数据库。同样，你可以比对并修改表的结构。在数据和结构同步中，目标数据库可以在源服务器，也可以在其他的服务器。</p>
<p>备份或还原<br>
定期备份数据库对用户是相当重要的。备份或还原全部表、记录、视图等。如果数据损坏，不用再重做，让你能高枕无忧。</p>
<p>计划<br>
不同数据库的设置文件可以创建在单一批处理作业，这样你就可以设置计划并在指定的时间运行。批处理作业可以创建的对象包括打印报表、数据库备份、查询、数据传输、数据同步、导入和导出。当任务完成后，Navicat 可自动传送电子邮件通知给你指定的收件人。此外，导出的文件或打印的报表可以添加到批处理作业作为电子邮件附件，让你可以轻易与其他人共享你的数据。<br>
报表创建工具或查看器 *只限于 Windows 版本</p>
<p>使用我们的用户友好 GUI 报表创建工具创建各种不同类型的报表。设计发票、统计、邮寄标签及更多其他报表。输出报表到多种格式 – text、PDF、Lotus、Excel、Graphic、Html 及更多。</p>
<p>Navicat Report Viewer 可让你浏览由报表创建工具设计的报表。最酷的是你可以与计算机沒有安装 Navicat，但安装了 Navicat Report Viewer 的人共享报表。</p>
<p>实用工具<br>
ER 图表<br>
ER 图表查看能通过以图形格式显示数据库结构来帮助你了解你的数据库，让你可以看到数据库中表之间的关联。</p>
<p>连接颜色或虚拟组<br>
连接颜色功能可以让你立刻知道你连接到哪个服务器。显示在子窗口工具栏的颜色指示，用于识别连接和它们的数据库对象。虚拟组功能分类对象到不用的组，令对象和连接有一个更好的组织。</p>
<p>树或对象筛选<br>
使用树或对象筛选功能收窄显示数据对象的列表。简单地需输入文本，然后只会显示符合指定字符串开始的数据库对象。</p>
<p>收藏夹<br>
Navicat 让你更容易地回到你常访问的数据库对象。通过添加路径到收藏夹列表，你只需一次点击就可以打开这些数据库对象。</p>
<p>系统需求<br>
Windows<br>
Microsoft Windows XP SP3、Vista、Windows 7、Windows 8、Windows 8.1、Windows 10、Server 2003、Server 2008、Server 2012</p>
<p>Mac<br>
Mac OS X 10.7 或以上版本<br>
Intel 处理器</p>
<p>Linux<br>
Ubuntu 12.04、Ubuntu 14.04、CentOS 6.7、CentOS 7、Fedora 22、Fedora 23、Linux Mint 13、Linux Mint 17.3、openSUSE 13.2、openSUSE 42.1</p>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于DeltaFox大神Navicat_Keygen_Patch_v5.6  Crazer汉化</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>使用前查看“使用说明&quot;文档<br>
或者<br>
<a href="https://acoldfront.github.io/post/navicat-keygen-patch/">查看Navicat产品_补丁_注册机 使用教程</a></p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1N32CbhM_-hIUdH_8zVzOPg">链接: https://pan.baidu.com/s/1N32CbhM_-hIUdH_8zVzOPg 提取码: 4vgd</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言求最小公倍数和最大公约数四种算法(经典)]]></title>
        <id>https://acoldfront.github.io/post/cdivisormultiple/</id>
        <link href="https://acoldfront.github.io/post/cdivisormultiple/">
        </link>
        <updated>2020-03-19T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p>最小公倍数：数论中的一种概念，两个整数公有的倍数成为他们的公倍数，其中一个最小的公倍数是他们的最小公倍数，同样地，若干个整数公有的倍数中最小的正整数称为它们的最小公倍数，维基百科：<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B8">定义点击打开链接</a><br>
求最小公倍数算法：<br>
最小公倍数=两整数的乘积÷最大公约数</p>
<p>求最大公约数算法：<br>
(1)辗转相除法：<br>
有两整数a和b：<br>
① a%b得余数c<br>
② 若c=0，则b即为两数的最大公约数<br>
③ 若c≠0，则a=b，b=c，再回去执行①</p>
<p>例如求27和15的最大公约数过程为：<br>
27÷15 余12，15÷12余3，12÷3余0，因此，3即为最大公约数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//辗转相除法求最大公约数
int main(void) {
    int m, n;
    int a, b, c;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    while (b != 0) {   //余数不为0，继续相除，直到余数为0
        c = a % b;
        a = b;
        b = c;
    }
    printf(&quot;最大公约数：%d\n&quot;, a);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / a);
    return 0;
}
</code></pre>
<p>提供一种简写的方式：</p>
<pre><code class="language-c">int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
</code></pre>
<p>⑵ 相减法：<br>
有两整数a和b：<br>
① 若a&gt;b，则a=a-b<br>
② 若a&lt;b，则b=b-a<br>
③ 若a=b，则a（或b）即为两数的最大公约数<br>
④ 若a≠b，则再回去执行①</p>
<p>例如求27和15的最大公约数过程为：<br>
27－15＝12( 15&gt;12 ) 15－12＝3( 12&gt;3 )<br>
12－3＝9( 9&gt;3 ) 9－3＝6( 6&gt;3 )<br>
6－3＝3( 3==3 )<br>
因此，3即为最大公约数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//相减法求最大公约数
int main(void) {
    int m, n;
    int a, b, c;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    while (a != b) {   //a, b不相等，大数减小数，直到相等为止。
        if (a &gt; b)
            a = a - b;
        else
            b = b - a;
    }
    printf(&quot;最大公约数：%d\n&quot;, a);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / a);
    return 0;
}
</code></pre>
<p>⑶穷举法：<br>
有两整数a和b：<br>
① i=1<br>
② 若a，b能同时被i整除，则t＝i<br>
③ i++<br>
④ 若 i &lt;= a(或b)，则再回去执行②<br>
⑤ 若 i &gt; a(或b)，则t即为最大公约数，结束</p>
<p>改进：<br>
① i= a(或b)<br>
② 若a，b能同时被i整除，则i即为最大公约数，<br>
结束<br>
③ i--，再回去执行②</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//穷举法求最大公约数
int main(void) {
    int m, n;
    int a, b, i, t;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    m = a;
    n = b;
    for (i = 1; i &lt;= a; ++i) {
        if (a % i == 0 &amp;&amp; b % i == 0)
            t = i;
    }
    /*  改进后的
    for (t= a; t&gt;0; t-- )
        if ( a%t == 0 &amp;&amp; b%t ==0 )
            break; 
    */
    printf(&quot;最大公约数：%d\n&quot;, t);
    printf(&quot;最小公倍数：%d\n&quot;, m * n / t);
    return 0;
}
</code></pre>
<pre><code class="language-c"> //穷举法求最小公倍数
for (i = a;; i++)
    if (i % a == 0 &amp;&amp; i % b == 0) break;
printf(&quot;最小公倍数：%d\n&quot;, i);

//多个数的最大公约数和最小公倍数
for (i = a; i &gt; 0; i--)
    if (a % i == 0 &amp;&amp; b % i == 0 &amp;&amp; c % i == 0)
        break;
printf(&quot;最大公约数：%d\n&quot;, i);
for (i = a;; i++)
    if (i % a == 0 &amp;&amp; i % b == 0 &amp;&amp; i % c == 0)
        break;
printf(&quot;最小公倍数：%d\n&quot;, i);
</code></pre>
<p>⑷取模法：<br>
求最小公倍数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最小公倍数
int main(void) {
    int x, y;
    int lcm;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    if (x &gt; y)
        lcm = x;
    else
        lcm = y;
    while (lcm % x || lcm % y)
        lcm++;
    printf(&quot;最小公倍数：%d\n&quot;, lcm);
    return 0;
}
</code></pre>
<p>求最大公约数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//求最大公约数
int main(void) {
    int x, y;
    int gcd;
    printf(&quot;请输入两个数：&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    if (x &gt; y)
        gcd = y;
    else
        gcd = x;
    while (x % gcd || y % gcd)
        gcd--;
    printf(&quot;最大公约数：%d\n&quot;, gcd);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言指针详解]]></title>
        <id>https://acoldfront.github.io/post/czhizhen/</id>
        <link href="https://acoldfront.github.io/post/czhizhen/">
        </link>
        <updated>2020-03-18T07:53:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么需要指针">为什么需要指针?</h1>
<p>指针解决了一些编程中基本的问题。</p>
<p>第一，指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。</p>
<p>第二，指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。</p>
<p>第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p>
<h1 id="指针是什么">指针是什么？</h1>
<p>我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。</p>
<p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = 'a'。</p>
<p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<p>因此：<strong>指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</strong><br>
<img src="https://acoldfront.github.io//post-images/1584518311428.png" alt="" loading="lazy"></p>
<h2 id="为什么程序中的数据会有自己的地址">为什么程序中的数据会有自己的地址？</h2>
<p>弄清这个问题我们需要从操作系统的角度去认知内存。</p>
<p>电脑维修师傅眼中的内存是这样的：内存在物理上是由一组DRAM芯片组成的。<br>
<img src="https://acoldfront.github.io//post-images/1584518333082.png" alt="" loading="lazy"><br>
而作为一个程序员，我们不需要了解内存的物理结构，操作系统将DRAM等硬件和软件结合起来，给程序员提供的一种对物理内存使用的抽象。<strong>这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作物理存储器</strong>。所有的虚拟地址形成的集合就是虚拟地址空间。<br>
<img src="https://acoldfront.github.io//post-images/1584518355076.png" alt="" loading="lazy"><br>
在程序员眼中的内存应该是下面这样的。（假设使用的是32位系统平台，虚拟存储空间为4GB）<br>
<img src="https://acoldfront.github.io//post-images/1584518367152.png" alt="" loading="lazy"><br>
也就是说，虚拟存储器是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。如上图中，这是一个4GB的虚拟存储器的模型，它一共有4x1024x1024x1024 个字节，那么它的虚拟地址范围就是 0 ~ 4x1024x1024x1024-1 。</p>
<p><strong>由于内存中的每一个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。</strong><br>
下面用代码说明</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    char ch = 'a';
    int  num = 97;
    printf(&quot;ch 的地址:%p\n&quot;,&amp;ch);   //ch 的地址:0028FF47
    printf(&quot;num的地址:%p\n&quot;,&amp;num);  //num的地址:0028FF40
    return 0;
}
</code></pre>
<p><img src="https://acoldfront.github.io//post-images/1584518411108.png" alt="" loading="lazy"><br>
指针的值实质是内存单元（即字节）的编号，所以指针 单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。<br>
我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节）<br>
<img src="https://acoldfront.github.io//post-images/1584518428498.png" alt="" loading="lazy"></p>
<h1 id="变量和内存">变量和内存</h1>
<p>为了简单起见，这里就用上面例子中的  int num = 97 这个局部变量来分析变量在内存中的存储模型。<br>
<img src="https://acoldfront.github.io//post-images/1584518486461.png" alt="" loading="lazy"><br>
已知：num的类型是int，占用了4个字节的内存空间，其值是97，地址是0028FF40。我们从以下几个方面去分析。</p>
<p>1、内存的数据</p>
<p>内存的数据就是变量的值对应的二进制，一切都是二进制。97的二进制是 : 00000000 00000000 00000000 0110000 , 但使用的<strong>小端模式</strong>存储时，低位数据存放在低地址，所以图中画的时候是倒过来的。</p>
<p>2、内存数据的类型</p>
<p>内存的数据类型决定了这个数据占用的字节数，以及计算机将如何解释这些字节。num的类型是int，因此将被解释为 一个整数。</p>
<p>3、内存数据的名称</p>
<p>内存的名称就是变量名。实质上，内存数据都是以地址来标识的，根本没有内存的名称这个说法，这只是高级语言提供的抽象机制 ，方便我们操作内存数据。而且在C语言中，并不是所有的内存数据都有名称，例如使用malloc申请的堆内存就没有。</p>
<p>4、内存数据的地址</p>
<p>如果一个类型占用的字节数大于1，则其变量的地址就是地址值最小的那个字节的地址。因此num的地址是 0028FF40。 内存的地址用于标识这个内存块。</p>
<p>5、内存数据的生命周期</p>
<p>num是main函数中的局部变量，因此当main函数被启动时，它被分配于栈内存上，当main执行结束时，消亡。</p>
<p>如果一个数据一直占用着他的内存，那么我们就说他是“活着的”，如果他占用的内存被回收了，则这个数据就“消亡了”。C语言中的程序数据会按照他们定义的位置，数据的种类，修饰的关键字等因素，决定他们的生命周期特性。实质上我们程序使用的内存会被逻辑上划分为：  栈区，堆区，静态数据区，方法区。不同的区域的数据有不同的生命周期。</p>
<p>无论以后计算机硬件如何发展，内存容量都是有限的，因此清楚理解程序中每一个程序数据的生命周期是非常重要的。</p>
<h1 id="指针变量-和-指向关系">指针变量 和 指向关系</h1>
<p>用来保存 指针 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。<br>
<img src="https://acoldfront.github.io//post-images/1584518528925.png" alt="" loading="lazy"><br>
上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。</p>
<p><strong>定义指针变量</strong></p>
<p>C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。</p>
<p>引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。</p>
<pre><code class="language-c">int a ; //int类型变量 a
int *a ; //int* 变量a
int arr[3]; //arr是包含3个int元素的数组
int (* arr )[3]; //arr是一个指向包含3个int元素的数组的指针变量


//-----------------各种类型的指针------------------------------

int* p_int; //指向int类型变量的指针 

double* p_double; //指向idouble类型变量的指针 

struct Student *p_struct; //结构体类型的指针

int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 

int(*p_arr)[3]; //指向含有3个int元素的数组的指针 

int** p_pointer; //指向 一个整形变量指针的指针
</code></pre>
<p><strong>取地址</strong></p>
<p>既然有了指针变量，那就得让他保存其它变量的地址，使用&amp; 运算符取得一个变量的地址。</p>
<pre><code class="language-c">int add(int a , int b)
{
    return a + b;
}

int main(void)
{
    int num = 97;
    float score = 10.00F;
    int arr[3] = {1,2,3};

    //-----------------------

    int* p_num = &amp;num;
    float* p_score = &amp;score;
    int (*p_arr)[3] = &amp;arr;           
    int (*fp_add)(int ,int )  = add;  //p_add是指向函数add的函数指针
    return 0;
}
</code></pre>
<p>特殊的情况，他们并不一定需要使用&amp;取地址：</p>
<ul>
<li>数组名的值就是这个数组的第一个元素的地址。</li>
<li>函数名的值就是这个函数的地址。</li>
<li>字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。</li>
</ul>
<pre><code class="language-c">int add(int a , int b){
    return a + b;
}
int main(void)
{
    int arr[3] = {1,2,3};
    //-----------------------
    int* p_first = arr;
    int (*fp_add)(int ,int )  =  add;
    const char* msg = &quot;Hello world&quot;;
    return 0;
}
</code></pre>
<p><strong>解地址</strong></p>
<p>我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个*号。</p>
<p>解指针的实质是：从指针指向的内存块中取出这个内存数据。</p>
<pre><code class="language-c">int main(void)
{
    int age = 19;
    int*p_age = &amp;age;
    *p_age  = 20;  //通过指针修改指向的内存数据

    printf(&quot;age = %d\n&quot;,*p_age);   //通过指针读取指向的内存数据
    printf(&quot;age = %d\n&quot;,age);

    return 0;
}
</code></pre>
<p><strong>指针之间的赋值</strong></p>
<p>指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。</p>
<pre><code class="language-c">int* p1  = &amp; num;
int* p3 = p1;

//通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://acoldfront.github.io//post-images/1584518724001.png" alt="" loading="lazy"></figure>
<p><strong>空指针</strong></p>
<p>指向空，或者说不指向任何东西。在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。</p>
<p>换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。</p>
<p>下面代码摘自 stddef.h</p>
<pre><code class="language-c">#ifdef __cplusplus
     #define NULL    0
#else    
     #define NULL    ((void *)0)
#endif
</code></pre>
<p><strong>坏指针</strong></p>
<p>指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。</p>
<p>任何一个指针变量在做 解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。</p>
<p>下面的代码就是错误的示例。</p>
<pre><code class="language-c">void opp()
{
     int*p = NULL;
     *p = 10;      //Oops! 不能对NULL解地址
}

void foo()
{
     int*p;
     *p = 10;      //Oops! 不能对一个未知的地址解地址
}

void bar()
{
     int*p = (int*)1000; 
     *p =10;      //Oops!   不能对一个可能不属于本程序的内存的地址的指针解地址
}
</code></pre>
<h2 id="指针的2个重要属性">指针的2个重要属性</h2>
<p>指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 指针的类型，指针的值。</p>
<pre><code class="language-c">int main(void)
{
    int num = 97;
    int *p1  = &amp;num;
    char* p2 = (char*)(&amp;num);

    printf(&quot;%d\n&quot;,*p1);    //输出  97
    putchar(*p2);          //输出  a
    return 0;
}
</code></pre>
<p>指针的值：很好理解，如上面的num 变量 ，其地址的值就是0028FF40 ，因此 p1的值就是0028FF40。数据的地址用于在内存中定位和标识这个数据，因为任何2个内存不重叠的不同数据的地址都是不同的。</p>
<p>指针的类型：指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息。一般指针变量的类型要和它指向的数据的类型匹配。</p>
<p>由于num的地址是0028FF40，因此p1  和  p2的值都是0028FF40</p>
<p>*p1  :  将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。</p>
<p>*p2  :  将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即'a'。</p>
<p>同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。</p>
<p><strong>void*类型指针</strong></p>
<p>由于void是空类型，因此void<em>类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void</em>类型的指针做解指针操作。</p>
<h2 id="结构体和指针">结构体和指针</h2>
<p>结构体指针有特殊的语法：  -&gt; 符号</p>
<p>如果p是一个结构体指针，则可以使用 p -&gt;【成员】 的方法访问结构体的成员。p-&gt;member 等价于 (*p).member。</p>
<pre><code class="language-c">typedef struct
{
    char name[31];
    int age;
    float score;
}Student;

int main(void)
{
    Student stu = {&quot;Bob&quot; , 19, 98.0};
    Student*ps = &amp;stu;

    ps-&gt;age = 20;
    ps-&gt;score = 99.0;
    printf(&quot;name:%s age:%d\n&quot;,ps-&gt;name,ps-&gt;age);
    return 0;
}
</code></pre>
<h2 id="数组和指针">数组和指针</h2>
<p>1、数组名作为右值的时候，就是第一个元素的地址。</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p_first = arr;
    printf(&quot;%d\n&quot;,*p_first);  //1
    return 0;
}
</code></pre>
<p>2、指向数组元素的指针 支持 递增 递减 运算。（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的）</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    for(;p!=arr+3;p++){
        printf(&quot;%d\n&quot;,*p); 
    }
    return 0;
}
</code></pre>
<p>3、p= p+1 意思是，让p指向原来指向的内存块的下一个相邻的相同类型的内存块。</p>
<p>同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。</p>
<p>4、p[n]    == *(p+n)<br>
p[n][m]  == *(  *(p+n)+ m )</p>
<p>5、当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。</p>
<p>这就是为什么我么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。</p>
<pre><code class="language-c">int main(void)
{
    int arr[3] = {1,2,3};
 
    int*p = arr;
    printf(&quot;sizeof(arr)=%d\n&quot;,sizeof(arr));  //sizeof(arr)=12
    printf(&quot;sizeof(p)=%d\n&quot;,sizeof(p));   //sizeof(p)=4
 
    return 0;
}
</code></pre>
<h1 id="函数和指针">函数和指针</h1>
<p><strong>函数的参数和指针</strong></p>
<p>C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p>
<pre><code class="language-c">void change(int a)
{
    a++;      //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。
}
int main(void)
{
    int age = 19;
    change(age);
    printf(&quot;age = %d\n&quot;,age);   // age = 19
    return 0;
}
</code></pre>
<p>有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。</p>
<p>传递变量的指针可以轻松解决上述问题。</p>
<pre><code class="language-c">void change(int* pa)
{
    (*pa)++;   //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时，
               //会直接去内存中找到age这个数据，然后把它增1。
}
int main(void)
{
    int age = 19;
    change(&amp;age);
    printf(&quot;age = %d\n&quot;,age);   // age = 20
    return 0;
}
</code></pre>
<p>再来一个老生常谈的，用函数交换2个变量的值的例子：</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void swap_bad(int a,int b);
void swap_ok(int*pa,int*pb);

int main()
{
    int a = 5;
    int b = 3;
    swap_bad(a,b);       //Can`t swap;
    swap_ok(&amp;a,&amp;b);      //OK
    return 0;
}

//错误的写法
void swap_bad(int a,int b)
{
    int t;
    t=a;
    a=b;
    b=t;
}

//正确的写法：通过指针
void swap_ok(int*pa,int*pb)
{
    int t;
    t=*pa;
    *pa=*pb;
    *pb=t;
}
</code></pre>
<p><img src="https://acoldfront.github.io//post-images/1584518999545.png" alt="" loading="lazy"><br>
<img src="https://acoldfront.github.io//post-images/1584519009838.png" alt="" loading="lazy"><br>
有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象，相反，我们防止这个目标数据被改变。传递指针只是为了避免拷贝大型数据。<br>
考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。</p>
<pre><code class="language-c">typedef struct
{
    char name[31];
    int age;
    float score;
}Student;
//打印Student变量信息
void show(const Student * ps)
{
    printf(&quot;name:%s , age:%d , score:%.2f\n&quot;,ps-&gt;name,ps-&gt;age,ps-&gt;score);   
}
</code></pre>
<p>我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。另外我们为什么要使用指针而不是直接传递Student变量呢？</p>
<p>从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。</p>
<p><strong>函数的指针</strong></p>
<p>每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。既然是存放在内存中，那么函数也是有自己的指针的。</p>
<p>C语言中，函数名作为右值时，就是这个函数的指针。</p>
<pre><code class="language-c">void echo(const char *msg)
{
    printf(&quot;%s&quot;,msg);
}
int main(void)
{
    void(*p)(const char*) = echo;   //函数指针变量指向echo这个函数

    p(&quot;Hello &quot;);      //通过函数的指针p调用函数，等价于echo(&quot;Hello &quot;)
    echo(&quot;World\n&quot;);
    return 0;
}
</code></pre>
<h2 id="const-和-指针">const 和 指针</h2>
<p>const到底修饰谁？谁才是不变的？</p>
<p>下面是我总结的经验，分享一下。</p>
<p>如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型）</p>
<p>如果const后面就是一个数据，则直接修饰这个数据。</p>
<pre><code class="language-c">int main()
{
    int a = 1;
   
    int const *p1 = &amp;a;        //const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值
    const int*p2 =  &amp;a;        //const后面是int类型，则跳过int ，修饰*p2， 效果同上

    int* const p3 = NULL;      //const后面是数据p3。也就是指针p3本身是const .

    const int* const p4 = &amp;a;  // 通过p4不能改变a 的值，同时p4本身也是 const
    int const* const p5 = &amp;a;  //效果同上

    return 0;

}
</code></pre>
<pre><code class="language-c">typedef int* pint_t;  //将 int* 类型 包装为 pint_t,则pint_t 现在是一个完整的原子类型

int main()
{
   
    int a  = 1;
    const pint_t p1 = &amp;a;  //同样，const跳过类型pint_t，修饰p1，指针p1本身是const
    pint_t const p2 = &amp;a;  //const 直接修饰p，同上
   
    return 0;

}
</code></pre>
<h2 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h2>
<p>如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。<br>
<img src="https://acoldfront.github.io//post-images/1584519118077.png" alt="" loading="lazy"></p>
<h1 id="附加知识">附加知识</h1>
<p>指针和引用这个2个名词的区别。他们本质上来说是同样的东西。指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。引用是编程语言提供给程序员的抽象机制，而指针是操作系统提供给软件开发模型的抽象机制。</p>
<p>大端模式和小端模式</p>
<ol>
<li>Little-Endian就是低字节排放在内存的低地址端，高字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。</li>
<li>B i g-Endian就是高字节排放在内存的低地址端，低字节排放在内存的高地址端。</li>
</ol>
<p>采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。有些机器同时支持大端和小端模式。</p>
<p>假如 short类型占用2个字节，且存储的地址为0x30。<br>
short a = 1;</p>
<p>如下图：<br>
<img src="https://acoldfront.github.io//post-images/1584518079493.png" alt="" loading="lazy"></p>
<pre><code class="language-c">//测试机器使用的是否为小端模式。是，则返回true，否则返回false
//这个方法判别的依据就是：C语言中一个对象的地址就是这个对象占用的字节中，地址值最小的那个字节的地址。

bool isSmallIndain()
{
      unsigned int val = 'A';
      unsigned char* p = (unsigned char*)&amp;val;  //C/C++：对于多字节数据，取地址是取的数据对象的第一个字节的地址，也就是数据的低地址
      
      return *p == 'A';
}
</code></pre>
<p>作者：lulipro-代码钢琴家<br>
转载出处：<a href="http://www.cnblogs.com/lulipro/">http://www.cnblogs.com/lulipro/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔的图解递归算法 - C语言版]]></title>
        <id>https://acoldfront.github.io/post/TowersOfHanoiC/</id>
        <link href="https://acoldfront.github.io/post/TowersOfHanoiC/">
        </link>
        <updated>2020-03-18T05:53:42.000Z</updated>
        <content type="html"><![CDATA[<p>三个盘子的汉诺塔<br>
<img src="https://acoldfront.github.io//post-images/1584511104143.gif" alt="" loading="lazy"><br>
然后你移完发现左边柱子下面又蹦出来一个盘子<br>
<img src="https://acoldfront.github.io//post-images/1584511163698.gif" alt="" loading="lazy"><br>
好吧, 那就把中间的柱子看成目标柱<br>
<img src="https://acoldfront.github.io//post-images/1584511216776.gif" alt="" loading="lazy"></p>
<p>所以说一共就三步：<br>
把 n-1 号盘子移动到缓冲区<br>
把1号从起点移到终点<br>
然后把缓冲区的n-1号盘子也移到终点</p>
<p>写成C语言代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void f(char a, char b) {
    printf(&quot;从%c柱上往%c柱上挪动一个圆盘\n&quot;, a, b);
}

void g(int i, char a, char b, char c) {
    if (i == 2) {   //2块圆盘
        f(a, b);    //把a柱子上 最上面的一块    挪动到 b柱子上去 
        f(a, c);    //把a柱子上 最下面（最大）的那一块   挪动到 c柱子上去 
        f(b, c);     //把b柱子上 那一块   挪动到 c柱子上去 
    } else if (i &gt; 2) { //分成a柱子上的圆盘 两部分： ①第i块 圆盘和②i-i块 圆盘
        //i-i块 圆盘那一部分
        g(i - 1, a, c, b);  //把a柱子上的 i-1块 圆盘通过c柱子 挪动到 b柱子上去 
        //第i块 圆盘那一部分
        f(a, c);              //把a柱子上的 第i块（最大的那一块）挪动到 c柱子上去 
        //对于b柱子上的i-i块 圆盘那一部分进行再次递归 转移
        g(i - 1, b, a, c); //把b柱子上的 i-1块 圆盘通过a柱子 挪动到 c柱子上去 
    }
}

int main(void) {
    g(3, 'A', 'B', 'C');
    return 0;
}
</code></pre>
<p>运行结果：<br>
<img src="https://acoldfront.github.io//post-images/1584511340054.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔的图解递归算法 - Java版]]></title>
        <id>https://acoldfront.github.io/post/TowersOfHanoiJava/</id>
        <link href="https://acoldfront.github.io/post/TowersOfHanoiJava/">
        </link>
        <updated>2020-03-18T05:24:03.000Z</updated>
        <content type="html"><![CDATA[<p>一．起源：<br>
　　汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>二．抽象为数学问题：<br>
　　如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数<br>
<img src="https://acoldfront.github.io//post-images/1584509080986.jpg" alt="" loading="lazy"><br>
解：</p>
<pre><code>（1）n == 1
                第1次  1号盘  A----&gt;C       sum = 1 次
（2)  n == 2
                第1次  1号盘  A----&gt;B
                第2次  2号盘  A----&gt;C
                第3次  1号盘  B----&gt;C        sum = 3 次
（3）n == 3
                第1次  1号盘  A----&gt;C
                第2次  2号盘  A----&gt;B
                第3次  1号盘  C----&gt;B
                第4次  3号盘  A----&gt;C
                第5次  1号盘  B----&gt;A
                第6次  2号盘  B----&gt;C
                第7次  1号盘  A----&gt;C        sum = 7 次
</code></pre>
<p>不难发现规律：</p>
<pre><code>1个圆盘的次数 2的1次方减1
2个圆盘的次数 2的2次方减1
3个圆盘的次数 2的3次方减1
。  。   。    。   。 
n个圆盘的次数 2的n次方减1
</code></pre>
<p>故：移动次数为：2^n - 1</p>
<p>三．调用方法的栈机制:（特点：先进后出）<br>
从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p>
<p>四．算法分析（递归算法）：<br>
我们在利用计算机求汉诺塔问题时，必不可少的一步是对整个实现求解进行算法分析。到目前为止，求解汉诺塔问题最简单的算法还是同过递归来求，至于是什么是递归，递归实现的机制是什么，我们说的简单点就是自己是一个方法或者说是函数，但是在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。</p>
<p>实现这个算法可以简单分为三个步骤：<br>
　　　　（1）把n-1个盘子由A 移到 B；<br>
　　　　（2）把第n个盘子由 A移到 C；<br>
　　　　（3）把n-1个盘子由B 移到 C；</p>
<p>从这里入手，在加上上面数学问题解法的分析，我们不难发现，移到的步数必定为奇数步：<br>
　　　　（1）中间的一步是把最大的一个盘子由A移到C上去；<br>
　　　　（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上，<br>
　　　　（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；</p>
<p>五，java源代码：</p>
<pre><code class="language-java">package demo;
/**
 * 目的：实现汉诺塔问题求解
 * 作者：Crazer
 */
import java.util.Scanner;

public class TowersOfHanoi {
    static int m =0;//标记移动次数
    //实现移动的函数
    public static void move(int disks,char N,char M)
    {
        System.out.println(&quot;第&quot; + (++m) +&quot; 次移动 : &quot; +&quot; 把 &quot;+ disks+&quot; 号圆盘从 &quot; + N +&quot; -&gt;移到-&gt;  &quot; + M);
    }
    //递归实现汉诺塔的函数
    public static void hanoi(int n,char A,char B,char C)
    {
        if(n == 1)//圆盘只有一个时，只需将其从A塔移到C塔
            TowersOfHanoi.move(1, A, C);//将编b号为1的圆盘从A移到C
        else
        {//否则
            hanoi(n - 1, A, C, B);//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔
            TowersOfHanoi.move(n, A, C);//把A塔上编号为n的圆盘移到C上
            hanoi(n - 1, B, A, C);//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔
        }
    }
    public static void main(String[] args) {
        Scanner imput = new Scanner(System.in);
        char A = 'A';
        char B = 'B';
        char C = 'C';
        System.out.println(&quot;******************************************************************************************&quot;);
        System.out.println(&quot;这是汉诺塔问题（把A塔上编号从小号到大号的圆盘从A塔通过B辅助塔移动到C塔上去&quot;);
        System.out.println(&quot;******************************************************************************************&quot;);
        System.out.print(&quot;请输入圆盘的个数：&quot;);
        int disks = imput.nextInt();
        TowersOfHanoi.hanoi(disks, A, B, C);
        System.out.println(&quot;&gt;&gt;移动了&quot; + m + &quot;次，把A上的圆盘都移动到了C上&quot;);
        imput.close();
    }

}
</code></pre>
<p>六．图解程序运行流程：<br>
（1）函数hanoi(int n,char A,char B,char C)的功能是把编号为n的圆盘借助B从A移动到 C上。<br>
（2）函数move(int n ,char N ,char M)的功能是把1编号为n的圆盘从N 移到M上<br>
<img src="https://acoldfront.github.io//post-images/1584509457983.png" alt="" loading="lazy"></p>
<p>七．程序运行截图：<br>
<img src="https://acoldfront.github.io//post-images/1584510142328.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特殊极限lim(x→∞)(1+1/x)^x的证明]]></title>
        <id>https://acoldfront.github.io/post/teshujixian/</id>
        <link href="https://acoldfront.github.io/post/teshujixian/">
        </link>
        <updated>2020-03-17T09:44:51.000Z</updated>
        <content type="html"><![CDATA[<p>同济版《高等数学第七版》对该极限有如下证明：<br>
<img src="https://acoldfront.github.io//post-images/1584438325548.png" alt="" loading="lazy"><br>
而夹逼定理为下面的两个准则：<br>
<img src="https://acoldfront.github.io//post-images/1584438336590.png" alt="" loading="lazy"><br>
<img src="https://acoldfront.github.io//post-images/1584438357871.png" alt="" loading="lazy"><br>
根据以上两个准则对照书中的证明不难发现，书中证明中的夹逼定理运用情况并不与上面的两个准则十分相符，在证明中，更像是两个数列夹着一个函数，而准则中并没有指出两个数列夹着一个函数有所谓夹逼定理。那么这里究竟是如何运用夹逼定理的呢？</p>
<p>事实上，“设n&lt;=x&lt;n+1”就已经说明了证明中的看似数列的部分并非数列，而是特殊的函数，也就是说，这个n与自变量x相关，这使得不等式左右两边看似为数列的两个式子并不是完全是我们平时所理解的数列。这个n是[x]，也就是对x取整后的值，是实数x的函数而不是平时我们定义数列时所认为的正整数(虽然它们的取值都一样)。</p>
<p>所以或许用下面的表达方式更容易理解为什么这里能够运用夹逼定理：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>exp</mi><mo>⁡</mo><mo>(</mo><mo>−</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} \exp(-x) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>设n=[x]，则n&lt;=x&lt;n+1，故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo>]</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">[1+\frac{1}{2}]^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>]</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">[1+\frac{1}{x}]^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msup><mo>]</mo><mo>(</mo></msup><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{n}]^(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2329999999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]+1}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>)</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">(1+\frac{1}{x})^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，</p>
<p>设函数g(x)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>，函数h(x)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，则</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> =<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>  ，因n=[x]，则当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">{x \to \infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∞</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">{n \to \infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∞</span></span></span></span></span>，故运用复合函数的极限运算法则知，</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mo>[</mo></msup><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{([x]+1)}]^[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><msup><mo>]</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} [1+\frac{1}{(n+1)}]^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> =e</p>
<p>同理有<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo>[</mo><mi>x</mi><mo>]</mo></mrow></mfrac><msup><mo>]</mo><mo>(</mo></msup><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{[x]}]^([x]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msup><mo>]</mo><mo>(</mo></msup><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} [1+\frac{1}{n}]^(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2329999999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> = e，</p>
<p>故由准则I`知，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo>[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><msup><mo>]</mo><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} [1+\frac{1}{x}]^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span> = e.</p>
]]></content>
    </entry>
</feed>