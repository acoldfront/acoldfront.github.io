<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-05T13:12:49.274Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-yu-yan-bian-cheng-shi-li-12hou-fen-kuai-cha-zhao-suan-fa-suo-yin-shun-xu-cha-zhao-suan-fa/</id>
        <link href="https://acoldfront.github.io/post/c-yu-yan-bian-cheng-shi-li-12hou-fen-kuai-cha-zhao-suan-fa-suo-yin-shun-xu-cha-zhao-suan-fa/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：11、二分查找算法，折半查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example11/</id>
        <link href="https://acoldfront.github.io/post/c-example11/">
        </link>
        <updated>2020-05-05T13:11:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：10、归并排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example10/</id>
        <link href="https://acoldfront.github.io/post/c-example10/">
        </link>
        <updated>2020-05-05T13:10:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：9、选择排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example9/</id>
        <link href="https://acoldfront.github.io/post/c-example9/">
        </link>
        <updated>2020-05-05T13:10:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：8、快速排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example8/</id>
        <link href="https://acoldfront.github.io/post/c-example8/">
        </link>
        <updated>2020-05-05T13:09:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：7、直接插入排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example7/</id>
        <link href="https://acoldfront.github.io/post/c-example7/">
        </link>
        <updated>2020-05-05T13:09:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：6、冒泡排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example6/</id>
        <link href="https://acoldfront.github.io/post/c-example6/">
        </link>
        <updated>2020-05-05T04:19:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 通过两个 for 循环实现冒泡排序的全过程，外层 for 循环决定冒泡排序的趟数，内层 for 循环决定每趟所进行两两比较的次数。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">int main(void) {
    int i, j, tmp, a[10];    //定义变量及数组为基本整型
    printf(&quot;请输入10个数：\n&quot;);
    for (int i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    for (i = 1; i &lt; 10; ++i) {  //变量i代表比较的趟数
        for (j = 0; j &lt; 10 - i; ++j) {  //变最j代表每趟两两比较的次数
            if (a[j] &gt; a[j + 1]) {
                tmp = a[j]; //产利用中间变童实现两值互换
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }

    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //将冒泡排序后的顺序输出
    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例要求用冒泡法对 10 个数由小到大进行排序，冒泡法的基本思路是，如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第 1 趟比较中要进行 n-j 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较。从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：5、希尔排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example5/</id>
        <link href="https://acoldfront.github.io/post/c-example5/">
        </link>
        <updated>2020-05-05T04:11:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：4、渔夫打鱼晒网]]></title>
        <id>https://acoldfront.github.io/post/c-example4/</id>
        <link href="https://acoldfront.github.io/post/c-example4/">
        </link>
        <updated>2020-05-05T03:58:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如果一个渔夫从 2011 年 1 月 1 日开始每三天打一次渔，两天晒一次网，编程实现当输入 2011 1 月 1 日以后的任意一天，输出该渔夫是在打渔还是在晒网。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1) 自定义函数 leap()，用来判断输入的年份是否是闰年。</p>
<p>(2) 自定义函数 number()，用来计算输入日期距 2011 年 1 月 1 日共有多少天。</p>
<p>(3) main() 函数作为程序的入口函数，在 main() 函数中调用上面两个函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int leap(int a) {   //自定义函数leap()用来指定输入的年份是否为闰年
    if (a % 4 == 0 &amp;&amp; a % 100 != 0 || a % 400 == 0)    //闰年判定条件
        return 1;   //是闰年返回1
    else
        return 0;   //不是闰年返回O
}

int number(int year, int month, int day) {    //自定义函数 number() 计算输入日期距2011年1月1日共有多少天
    int sum = 0, i, j, k;
    int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组a存放平年每月的天数
    int b[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    //数组b存放闰年每月的天数
    if (leap(year) == 1) {    //判断是否为闰年
        for (i = 0; i &lt; month - 1; ++i)
            sum += b[i];    //是闰年，累加数组b前m-1个月份的天数
    } else {
        for (i = 0; i &lt; month - 1; ++i)
            sum += a[i];    //不是闰年，累加数组a前m-1个月份的天数
    }
    for (j = 2011; j &lt; year; ++j) {
        if (leap(j) == 1)
            sum += 366;   //2011年到输入的年份是闰年的加366
        else
            sum += 365;   //2011年到输入的年份不是闰年的加365
    }
    sum += day;    //将前面累加的结果加上日期，求出总天数
    return sum; //返回计算的天数
}

int main(void) {
    int year, month, day, n;
    printf(&quot;请输入年月日\n&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;year, &amp;month, &amp;day);    //输入年月日
    n = number(year, month, day);
    if ((n % 5) &lt; 4 &amp;&amp; (n % 5) &gt; 0)    //余数是1或2或3时说明在打渔，否则在晒网
        printf(&quot;%d：%d：%d 打鱼\n&quot;, year, month, day);
    else
        printf(&quot;%d：%d：%d 晒网\n&quot;, year, month, day);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入年月日
2011 1 4
2011：1：4 晒网
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例主要有以下两个技术要点：</p>
<p>(1) 判断输入的年份（2011 年以后包括 2011 年）是否为闰年，这里自定义函数 leap() 来进行判断。该函数的核心内容就是闰年的判断条件即能被 4 整除但不能被 100 整除，或能被 400 整除。</p>
<p>(2) 求输入日期距 2011 年 1 月 1 日有多少天。首先判断 2011 年距输入的年份有多少年，这其中有多少年是闰年就将 sum 加多少个 366，有多少年是平年便将 sum 加上多少个 365。</p>
<p>其次要将 12 个月每月的天数存到数组中，因为闰年 2 月份的天数有别于平年，故采用两个数组 a 和 b 分别存储。若输入年份是平年，月份为 m 时就在前面累加日期的基础上继续累加存储着平年每月天数的数组的前 m-1 个元素，将累加结果加上输入的日期便求出了最终结果。闰年的算法类似。</p>
]]></content>
    </entry>
</feed>