<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-05-06T03:26:55.061Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：13、求n的阶乘（n!）]]></title>
        <id>https://acoldfront.github.io/post/c-example13/</id>
        <link href="https://acoldfront.github.io/post/c-example13/">
        </link>
        <updated>2020-05-06T03:20:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先要清楚阶乘定义，所谓 n 的阶乘，就是从 1 开始乘以比前一个数大 1 的数，一直乘到 n，用公式表示就是：1×2×3×4×…×(n-2)×(n-1)×n=n!</p>
<p>具体的操作:利用循环解决问题，设循环变量为 i，初值为 1，i 从 1 变化到 n；依次让 i 与 sum 相乘，并将乘积赋给 sum。<br>
① 定义变量 sum，并赋初值 1。<br>
② i 自增 1。<br>
③ 直到 i 超过 n。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, n;
    double sum = 1,sum1=1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法一；
    for (i = 1; i &lt;= n; ++i) {
        sum *= i;
    }
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<hr>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//使用递归
double f(int n) {
    if (n == 1)
        return 1;
    else
        return n * f(n - 1);
}
int main(void) {
    int i, n;
    double sum = 1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法二：
    sum = f(n);//使用递归
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 由于阶乘一般较大，会超出整型甚至是长整型所能表示的范围，因此定义变量时就不能定义为整型，而应该考虑双精度数。</p>
<p>② 实训中定义了一个双精度型的变量，用来存放结果。因此在输出时应注意双精度数的输出格式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：13、求n的阶乘（n!）]]></title>
        <id>https://acoldfront.github.io/post/c-yu-yan-bian-cheng-shi-li-13qiu-n-de-jie-cheng-n/</id>
        <link href="https://acoldfront.github.io/post/c-yu-yan-bian-cheng-shi-li-13qiu-n-de-jie-cheng-n/">
        </link>
        <updated>2020-05-06T03:20:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>从键盘输入一个数，求出这个数的阶乘，即 n!。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想</strong><br>
首先要清楚阶乘定义，所谓 n 的阶乘，就是从 1 开始乘以比前一个数大 1 的数，一直乘到 n，用公式表示就是：1×2×3×4×…×(n-2)×(n-1)×n=n!</p>
<p>具体的操作:利用循环解决问题，设循环变量为 i，初值为 1，i 从 1 变化到 n；依次让 i 与 sum 相乘，并将乘积赋给 sum。<br>
① 定义变量 sum，并赋初值 1。<br>
② i 自增 1。<br>
③ 直到 i 超过 n。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, n;
    double sum = 1,sum1=1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法一；
    for (i = 1; i &lt;= n; ++i) {
        sum *= i;
    }
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<hr>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//使用递归
double f(int n) {
    if (n == 1)
        return 1;
    else
        return n * f(n - 1);
}
int main(void) {
    int i, n;
    double sum = 1;
    printf(&quot;请输入数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    //方法二：
    sum = f(n);//使用递归
    printf(&quot;%d!=%.2lf&quot;, n, sum);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数：5
5!=120.00
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 由于阶乘一般较大，会超出整型甚至是长整型所能表示的范围，因此定义变量时就不能定义为整型，而应该考虑双精度数。</p>
<p>② 实训中定义了一个双精度型的变量，用来存放结果。因此在输出时应注意双精度数的输出格式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：12、猴分块查找算法，索引顺序查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example12/</id>
        <link href="https://acoldfront.github.io/post/c-example12/">
        </link>
        <updated>2020-05-05T13:12:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>例如，采用分块查找法在有序表 11、12、18、28、39、56、69、89、96、122、135、146、156、256、298 中查找关键字为 96 的元素。</p>
</blockquote>
<!-- more -->
<p>査找特定关键字元素个数为 15，要求用户输入有序表各元素，程序输出査找成功与否，若成功，还显示元素在有序表中的位罝。</p>
<p><strong>实现过程：</strong><br>
(1)定义结构体 index，用于存储块的结构，并定义该结构体数组 index_table。</p>
<p>(2)自定义函数 block_search()，实现分块查找。</p>
<p>(3) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct index    //定义块的结构
{
    int key;    //块的关键字
    int start;    //块的起始值
    int end;    //块的结束值
} index_table[4];    //定义结构体数组

int block_search(int key, int a[])    //自定义实现分块查找
{
    int i, j;
    i = 1;
    while (i &lt;= 3 &amp;&amp; key &gt; index_table[i].key)    //确定在哪个块中
        i++;
    if (i &gt; 3)    //大于分得的块数，则返回0
        return 0;
    j = index_table[i].start;    //j等于块范围的起始值
    while (j &lt;= index_table[i].end &amp;&amp; a[j] != key)    //在确定的块内进行顺序查找
        j++;
    if (j &gt; index_table[i].end)    //如果大于块范围的结束值，则说明没有要査找的数，j置0
        j = 0;
    return j;
}

int main() {
    int i, j = 0, k, key, a[16];
    printf(&quot;请输入15个数：\n&quot;);
    for (i = 1; i &lt; 16; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //输入由小到大的15个数
    for (i = 1; i &lt;= 3; i++) {
        index_table[i].start = j + 1;    //确定每个块范围的起始值
        j = j + 1;
        index_table[i].end = j + 4;    //确定每个块范围的结束值
        j = j + 4;
        index_table[i].key = a[j];    //确定每个块范围中元素的最大值
    }
    printf(&quot;请输入你想査找的元素：\n&quot;);
    scanf(&quot;%d&quot;, &amp;key);    //输入要查询的数值
    k = block_search(key, a);    //调用函数进行杳找
    if (k != 0)
        printf(&quot;查找成功，其位置是：%d\n&quot;, k);    //如果找到该数，则输出其位置
    else
        printf(&quot;查找失败!&quot;);    //若未找到，则输出提示信息
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入15个数：
11 12 18 28 39 56 69 89 96 122 135 146 156 256 298
请输入你想査找的元素：
96
查找成功，其位置是：9
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>分块査找也称为索引顺序査找，要求将待查的元素均匀地分成块，块间按大小排序，块内不排序，所以要建立一个块的最大（或最小）关键字表，称为索引表。</p>
<p>本实例中将给出的 15 个数按关键字大小分成了 3 块，这 15 个数的排列是一个有序序列，也可以给出无序序列，但必须满足分在第一块中的任意数都小于第二块中的所有数，第二块中的所有数都小于第三块中的所有数。当要査找关键字为 key 的元素时，先用顺序杳找在已建好的索引表中查出 key 所在的块中，再在对应的块中顺序查找 key，若 key 存在，则输出其相应位置，否则输出提示信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：11、二分查找算法，折半查找算法]]></title>
        <id>https://acoldfront.github.io/post/c-example11/</id>
        <link href="https://acoldfront.github.io/post/c-example11/">
        </link>
        <updated>2020-05-05T13:11:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和査找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表 11、13、18、 28、39、56、69、89、98、122 中査找关键字为 89 的元素。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>折半查找法也叫做二分查找，顾名思义，就是把数据分成两半，再判断所查找的key在哪一半中，再重复上述步骤知道找到目标key;<br>
<strong>注意：（咳咳，敲黑板）折半查找法仅适用于对已有顺序的数组、数据进行操作！！！</strong></p>
<p>折半查找只能在有序数列中进行，将待查找的数据与有序数列（递增）中间的元素进行比较，如果相等，则找到；如果待查找的数据大于中间的元素的值，那么再从数组的后一半元素中进行查找，否则，从前一半元素中进行查找；若折半后都找不到，则输出“没找着”等提示信息。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：要在数组arr[]={8,7,9,6,4,1,2,5,3,10,11};中查找key=7的位置；首先，我们要先将数组arr中的数据成员进行排序。arr[]={1,2,3,4,5,6,7,8,9,10,11};<br>
<img src="https://acoldfront.github.io//post-images/1588696496749.png" alt="" loading="lazy"><br>
如图所示：将该组数据小端记作low，大端记作high,中间值记作mid;<br>
二分法查找时，将所查找的key与mid比较，例如key=7，即可缩小查找范围在mid和high之间；<br>
<img src="https://acoldfront.github.io//post-images/1588696476328.png" alt="" loading="lazy"><br>
如图所示即可找到key=low=7;<br>
<strong>注意：（敲黑板）如果中间数mid不是整数，需要进行取整。</strong></p>
<p><strong>实现过程：</strong><br>
(1) 自定义函数 binary_search()，实现二分査找。</p>
<p>(2) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int binary_search(int key, int a[], int n) { //自定义函数binary_search()

    int low, high, mid, count = 0, count1 = 0;
    low = 0;
    high = n - 1;
    while (low &lt; high)    //査找范围不为0时执行循环体语句
    {
        count++;    //count记录査找次数
        mid = (low + high) / 2;    //求中间位置
        if (key &lt; a[mid])    //key小于中间值时
            high = mid - 1;    //确定左子表范围
        else if (key &gt; a[mid])    //key 大于中间值时
            low = mid + 1;    //确定右子表范围
        else if (key == a[mid])    //当key等于中间值时，证明查找成功
        {
            printf(&quot;查找成功!\n 查找 %d 次!a[%d]=%d&quot;, count, mid, key);    //输出査找次数及所査找元素在数组中的位置
            count1++;    //count1记录查找成功次数
            break;
        }
    }
    if (count1 == 0)    //判断是否查找失敗
        printf(&quot;查找失敗!&quot;);    //査找失敗输出no found
    return 0;
}

int main() {
    int i, key, a[100], n;
    printf(&quot;请输入数组的长度：\n&quot;);
    scanf(&quot;%d&quot;, &amp;n);    //输入数组元素个数
    printf(&quot;请输入数组元素：\n&quot;);
    for (i = 0; i &lt; n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //输入有序数列到数组a中
    printf(&quot;请输入你想查找的元素：\n&quot;);
    scanf(&quot;%d&quot;, &amp;key);    //输入要^找的关键字
    binary_search(key, a, n);    //调用自定义函数
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入数组的长度：
10
请输入数组元素：
2   3   5   6   8   10  12  13  15  18
请输入你想查找的元素：
8
查找成功!
 查找 1 次!a[4]=8
</code></pre>
<hr>
<p><strong>方法二：</strong></p>
<pre><code class="language-c">int BinSearch(int arr[], int len, int key) {                         //折半查找法（二分法）
    int low = 0;                         //定义初始最小
    int high = len - 1;                 //定义初始最大
    int mid;                            //定义中间值
    while (low &lt;= high) {
        mid = (low + high) / 2;              //找中间值
        if (key == arr[mid])               //判断min与key是否相等
            return mid;
        else if (key &gt; arr[mid])             //如果key&gt;mid  则新区间为[mid+1,high]
            low = mid + 1;
        else                                       //如果key&lt;mid  则新区间为[low,mid-1]
            high = mid - 1;
    }
    return -1;                             //如果数组中无目标值key，则返回 -1 ；
}

void main() {
    int a[] = {2, 3, 5, 6, 8, 10, 12, 13, 15, 18};//二分搜索是已排好序
    int i, n, addr;
    printf(&quot;the array is:\n&quot;);
    for (i = 0; i &lt; sizeof(a) / sizeof(int); i++)
        printf(&quot;%-4d&quot;, a[i]);
    printf(&quot;\nsearch number is:&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    addr = BinSearch(a, sizeof(a) / sizeof(int), n);
    if (-1 == addr)
        printf(&quot;can't find!\n&quot;);
    else
        printf(&quot;the %d is %dth at the array.\n&quot;, n, addr);
}
</code></pre>
<p>输出结果：</p>
<pre><code>the array is:
2   3   5   6   8   10  12  13  15  18
search number is:8
the 8 is 4th at the array.
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>·二分査找就是折半查找，其基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：10、归并排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example10/</id>
        <link href="https://acoldfront.github.io/post/c-example10/">
        </link>
        <updated>2020-05-05T13:10:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用归并排序法对一组数据由小到大进行排序，数据分别为 695、458、362、789、12、 15、163、23、2、986。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>归并排序的基本原理是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。其实通俗来说，对于一个数来说自身是有序的，然后每次选取两个数使之自身有序，然后每次选取四个数使之自身有序，以后以二倍增长选择，进行排序。将若将两有个有序表合成一个有序表，成为二路归并。（具体可以依据下图进行分析）</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：15、2、35、6、23、11、5<br>
说明：其中s1,s2,e1,e2 分别表示两个归并段的首尾位置，brr[]为辅助数组，arr[]为存储结果的数组。<br>
具体步骤：<br>
<img src="https://acoldfront.github.io//post-images/1588695126632.png" alt="" loading="lazy"></p>
<p><strong>实现过程：</strong><br>
(1) 自定义函数 merge()，实现一次归并排序。</p>
<p>(2) 自定义函数 merge_sort()，实现归并排序。</p>
<p>(3) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int merge(int r[], int s[], int x1, int x2, int x3) {   //自定义实现一次归并样序的函数

    int i, j, k;
    i = x1;    //第一部分的开始位置
    j = x2 + 1;  //第二部分的开始位置
    k = x1;
    while ((i &lt;= x2) &amp;&amp; (j &lt;= x3))    //当i和j都在两个要合并的部分中时
        if (r[i] &lt;= r[j])    //筛选两部分中较小的元素放到数组s中
        {
            s[k] = r[i];
            i++;
            k++;
        } else {
            s[k] = r[j];
            j++;
            k++;
        }
    while (i &lt;= x2)    //将x1〜x2范围内未比较的数顺次加到数组r中
        s[k++] = r[i++];
    while (j &lt;= x3) //将x2+l〜x3范围内未比较的数顺次加到数组r中
        s[k++] = r[j++];
    return 0;
}

int merge_sort(int r[], int s[], int m, int n) {
    int p;
    int t[20];
    if (m == n)
        s[m] = r[m];
    else {
        p = (m + n) / 2;
        merge_sort(r, t, m, p);    //递归调用merge_soit()函数将r[m]〜r[p]归并成有序的t[m]〜t[p]
        merge_sort(r, t, p + 1, n);    //递归一调用merge_sort()函数将r[p+l]〜r[n]归并成有序的t[p+l]〜t[n]
        merge(t, s, m, p, n);    //调用函数将前两部分归并到s[m]〜s[n】*/
    }
    return 0;
}

int main(void) {
    int a[11];
    int i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //从键盘中输入10个数
    merge_sort(a, a, 1, 10);    //调用merge_sort()函数进行归并排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数据
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
695 458 362 789 12 15 163 23 2 986
排序后的顺序是：
    8   12   15   23  163  362  458  695  789  986
</code></pre>
<hr>
<p>** 方法二 **</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void Merge(int *arr,int len,int gap)
{
    int *brr = (int *)malloc(sizeof(int) * len);  //动态开辟辅助数组
    assert(brr != NULL);
    int i = 0;           //brr的下标
    int start1 = 0;
    int end1 = start1+gap-1;
    int start2 = end1+1;
    int end2 = start2 + gap - 1 &lt; len - 1 ? start2 + gap - 1 : len - 1 ;     //当有两个归并段的时候
    while(start2 &lt; len)
    {
        //当两个归并段还没有比较完的时候
        while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        {
            if(arr[start1] &lt;= arr[start2])
            {
                brr[i++] = arr[start1++];
            }
            else
            {
                brr[i++] = arr[start2++];
            }
        }
        while(start1 &lt;= end1)     //如果是第二个归并段比较完了，则将第一个归并段中的数放在brr[]
        {
            brr[i++] = arr[start1++];
        }
        while(start2 &lt;= end2)  //如果是第一个归并段比较完了，则将第二个归并段中的数放在brr[]
        {
            brr[i++] = arr[start2++];
        }
        //找两个新的归并段
        start1 = end2+1;
        end1 = start1+gap-1;
        start2 = end1+1;
        end2 = start2+gap-1 &lt; len-1?start2+gap-1:len-1;
    }
    while(start1 &lt; len)  //如果在最后不存在第二个归并段，则将第一个归并段中的数放在brr[]
    {
        brr[i++] = arr[start1++];
    }
    for(int i = 0;i &lt; len;i++)    //数值拷贝
    {
        arr[i] = brr[i];
    }
}
void MergeSort(int *arr,int len)
{
    for(int i = 1;i &lt; len;i *= 2)   //i表示分组数，分组形式为1 2 4 8....
    {
        Merge(arr,len,i);
    }
}

int main(void) {
    int a[11];
    int i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);    //从键盘中输入10个数
    MergeSort(a,10);    //调用merge_sort()函数进行归并排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数据
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
695 458 362 789 12 15 163 23 2 986
排序后的顺序是：
    8   12   15   23  163  362  458  695  789  986
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>归并是将两个或多个存序记录序列合并成一个有序序列。归并方法有多种，一次对两个有序记录序列进行归并，称为路归并排序，也有三路归并排序及多路归并排序。本实例是二路归并排序，基本方法如下：</p>
<p>(1) 将 n 个记录看成是 n 个长度为 1 的有序子表。</p>
<p>(2) 将两两相邻时有序无表进行归并。</p>
<p>(3) 重复执行步骤 (2) 直到归并成一个长度为 n 的有序表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：9、选择排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example9/</id>
        <link href="https://acoldfront.github.io/post/c-example9/">
        </link>
        <updated>2020-05-05T13:10:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用选择排序法对一组数据由小到大进行排序，数据分别为 526、36、2、369、56、45、78、92、125、52。</p>
</blockquote>
<!-- more -->
<h3 id="算法表述">算法表述：</h3>
<p>选择排序的基本原理是以序列首元素位置为基准位置，每次将该基准位置的元素和后面元素逐个进行比较，挑选最大或者最小的那个数放在基准位置上，一趟比较结束后，然后将基准位置设置为该位置的下一位置，重复上述操作，直到基准被安排在序列的最后有一个位置时，此时序列已经排列完成。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：88、5、15、56、32、18、69<br>
说明：按照从小到大的顺序进行排序，其中每条彩色线条为两数之间的比较,其条数为比较次数.图示为比较结果,过程较为简单,请读者自行分析.<br>
(1)第一躺比较：<br>
<img src="https://acoldfront.github.io//post-images/1588694020653.png" alt="" loading="lazy"><br>
此时最小数5已经放在最开始的位置。<br>
(2)第二趟比较：<br>
<img src="https://acoldfront.github.io//post-images/1588694033043.png" alt="" loading="lazy"><br>
此时将第二小的数字放在当前序列的开头<br>
(3)第三趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588694046856.png" alt="" loading="lazy"><br>
此时将第三小的数字放在当前序列的开头<br>
以此类推，可得到最终结果为：5、15、18、32、56、69、88</p>
<p><strong>实现过程：</strong><br>
(1) 程序中用到T两个 for 循环语句。第一个 for 循环是确定位置的，该位置是存放每次从待排序数列中经选择和交换后所选出的最小数。第二个 for 循环是实现将确定位置上的数与后面待排序区间中的数进行比较的。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void Selset_Sort(int s[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n; ++i) {
        for (j = i + 1; j &lt; n; ++j) {
            if (s[i] &gt; s[j]) {  //如果前一个数比后一个数大，则利用中间变量t实现两值互换
                temp = s[i];
                s[i] = s[j];
                s[j] = temp;
            }
        }
    }
}

int main(void) {
    int b[10], j;
    printf(&quot;请输入10个数：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        scanf(&quot;%d&quot;, &amp;b[j]);
    Selset_Sort(b, 10);         //调用快速排序函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        printf(&quot;%-4d&quot;, b[j]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
526 36 2 369 56 45 78 92 125 52
排序后的顺序是：
2   36  45  52  56  78  92  125 369 526
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>选择排序的基本算法是从待排序的区间中经过选择和交换后选出最小的数值存放到 a[0] 中，再从剩余的未排序区间中经过选择和交换后选出最小的数值存放到 a[1] 中，a[1] 中的数字仅大于 a[0]，依此类推，即可实现排序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：8、快速排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example8/</id>
        <link href="https://acoldfront.github.io/post/c-example8/">
        </link>
        <updated>2020-05-05T13:09:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用快速排序法对一组数据由小到大进行排序，数据分别为 99、45、12、36、69、22、62、 796、4、696。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>快速排序算法的基本原理为通过一次排序将要排序的数据分割成独立的两部分，将序列分为两部分的中间数作为基准(par)，基准左边的数都要比基准右边的数要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：8，15，26，18，7，66，44<br>
分析：依靠基准将序列分割为两部分，那么基准如何找到呢？？？？？？<br>
方法有三种：</p>
<p>固定位置选取基准法              <br>
随机选取基准法<br>
三分取中法<br>
具体步骤：<br>
一次取基准(par)过程：设置一个临时变量temp，并以第一个数作为temp的值，设置两个指针low和high。low指向序列的起始位置，high指向序列的最后一个元素。首先我们用high指向的元素和temp进行比较，如果大于，指针回退，直到high指向的元素值小于temp，然后让low指向的值赋值为high的值。这时让low指向的元素和temp比较，如果low指向的元素小于temp，指针前进，直到low指向的元素值大于temp。这时让high指向的值赋值为low指向的值，接下来对high重复上述操作，直到high和low相遇。此时的位置就是基准的位置par，最后此位置赋值temp。（具体可依据下图进行分析）</p>
<p>说明：</p>
<ul>
<li>下图每一步为指针的循环操作，直至不符合条件，并且进行赋值变换后的结果。</li>
<li>上述一次取基准的过程采用了固定位置选取基准法。（另外两种方法后面将进行介绍）<br>
<img src="https://acoldfront.github.io//post-images/1588691937722.png" alt="" loading="lazy"><br>
然后对左右两部分子序列继续进行此步骤。（如果子序列为单个数时，说明自身有序，不进行此过程）</li>
</ul>
<p><strong>实现过程：</strong><br>
(1) 自定义一个函数，实现直接插入排序，在本实例中，我们自定义该函数为 insort()。</p>
<p>(2) main() 函数为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int qusort(int s[], int start, int end) {    //自定义函数 qusort()
    int i, j;    //定义变量为基本整型
    i = start;    //将每组首个元素赋给i
    j = end;    //将每组末尾元素赋给j
    s[0] = s[start];    //设置基准值
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; s[0] &lt; s[j])
            j--;    //位置左移
        if (i &lt; j) {
            s[i] = s[j];    //将s[j]放到s[i]的位置上
            i++;    //位置右移
        }
        while (i &lt; j &amp;&amp; s[i] &lt;= s[0])
            i++;    //位置左移
        if (i &lt; j) {
            s[j] = s[i];    //将大于基准值的s[j]放到s[i]位置
            j--;    //位置左移
        }
    }
    s[i] = s[0];    //将基准值放入指定位置
    if (start &lt; i)
        qusort(s, start, j - 1);    //对分割出的部分递归调用qusort()函数
    if (i &lt; end)
        qusort(s, j + 1, end);
    return 0;
}

int main(void) {
       int a[10], i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    QuickSort(a, 0, 9);    //调用qusort()函数进行排序
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        printf(&quot;%5d&quot;, a[i]);    //将排序后的顺序输出
    }

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
99 45 12 36 69 22 62 796 4 696
排序后的顺序是：
    4   12   22   36   45   62   69   99  696  796
</code></pre>
<hr>
<h3 id="快速排序原理">快速排序原理：</h3>
<p>从序列“2,3,5,7,9,6,4,1,0,8”两端开始<br>
（1）首先将2作为基准数，应用2个变量i和j分别指向序列左端和右端；<br>
（2）首先从j左往右寻找一个小于2的数，i从右往左寻找一个大于2的数；<br>
（3）找到了0和3进行第一次交换，继续搜索；<br>
（4）1和5进行第二次交换；<br>
（5）当i和j都到1数值1时，表明第一轮交换结束，将基准数2和1进行交换，以基准数2为分界点，2的左边都小于等于2,2的右边都大于等于2；<br>
（6）2的左边序列为“1,0”，2的右边序列为“7,9,6,4,5,3,8”；<br>
（7）最后调用递归分别处理左边序列和右边序列即可。<br>
<img src="https://acoldfront.github.io//post-images/1588693747080.png" alt="" loading="lazy"></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void QuickSort(int a[], int left, int right) {
    int i, j, temp, tp;
    temp = a[left];                 //暂存基准数
    i = left;                       //最左位置
    j = right;                      //最右位置

    if (left &gt; right)                //递归结束条件
        return;
    while (i != j)                  //当i和j不重合时
    {
        while (a[j] &gt;= temp &amp;&amp; i &lt; j) //从右往左寻找小于基准数的值
            j--;
        while (a[i] &lt;= temp &amp;&amp; i &lt; j) //从左往右寻找大于基准数的值
            i++;
        //找到了且i&lt;j则交换数值
        if (i &lt; j) {
            tp = a[i];
            a[i] = a[j];
            a[j] = tp;
        }
    }

    //将基准数和i、j的相遇数值进行交换
    a[left] = a[i];
    a[i] = temp;

    //应用递归对此时基准数的左边进行快速排序
    QuickSort(a, left, i - 1);
    //应用递归对此时基准数的右边进行快速排序
    QuickSort(a, i + 1, right);
}

int main(void) {
    int b[10], j;
    printf(&quot;请输入10个数：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        scanf(&quot;%d&quot;, &amp;b[j]);
    QuickSort(b, 0, 9);         //调用快速排序函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (j = 0; j &lt; 10; j++)
        printf(&quot;%-4d&quot;,b[j]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
99 45 12 36 69 22 62 796 4 696
排序后的顺序是：
    4   12   22   36   45   62   69   99  696  796
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>快速排序是冒泡排序的一种改进，主要的算法思想是在待排序的 n 个数据中取第一个数据作为基准值，将所有记录分为 3 组，使第一组中各数据值均小于或等于基准值，第二组做基准值的数琚，第三组中各数据值均大于或等于基准值。这便实现了第一趟分割，然后再对第二组和第兰组分别重复上述方法，依次类推，直到每组中只有一个记录为止。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：7、直接插入排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example7/</id>
        <link href="https://acoldfront.github.io/post/c-example7/">
        </link>
        <updated>2020-05-05T13:09:08.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。本实例要求使用直接插入排序法将数字由小到大进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>直接插入排序的基本原理就如同打扑克牌一样，起初在摸牌的时候，第一张牌对于自身而言是有序的，假如摸到4，当第二次摸到6时，会将6放在4的后面，第三次摸到3时，会将3放在4的前面，这个过程就是直接插入排序。那么对于6和3而言，如何知道是大还是小呢？过程很简单，每摸到一张牌就和前面已有序数列作比较比较，然后交换顺序即可。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如:8、45、18、33、15、99、3<br>
说明：按照从小到大的顺序进行排序。</p>
<p>具体实现步骤如下：设置一个临时变量temp，其值为当前所摸牌的值，然后和它的前一张牌（即已有序列的最后一张牌）开始比较，如果temp小于前一张牌的值，就把前一张牌放在当前位置，结果比较有序序列的倒数第二位置，如果再小，重复上述步骤，如果大于，由于比较的是有序序列，故此是为有序状态，最后把temp的值放在和有序序列中最后一个比较的值的下一位置当有序之后，退出循环。具体可根据下述图进行自行分析。<br>
备注：</p>
<ul>
<li>其中i表示当前所摸的牌，j表示已有序数列的最后一张牌，从后往前比较。</li>
<li>其中蓝色空格为temp的值,不代表方框中的值,彩色线条为两数之间的比较。</li>
<li>以下每一步均为比较完变化后的结果。<br>
(1)第一趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689732582.png" alt="" loading="lazy"><br>
(2)第二趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588690023139.png" alt="" loading="lazy"><br>
以此类推...<br>
(3)第六趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588689972515.png" alt="" loading="lazy"><br>
此时待排序列已全部有序。<br>
拓展：n个数排序需要n - 1躺。</li>
</ul>
<p><strong>实现过程：</strong><br>
(1) 自定义一个函数，实现直接插入排序，在本实例中，我们自定义该函数为 insort()。</p>
<p>(2) main() 函数为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int insort(int s[], int n) {    //自定义函数 insort()
    int i, j, temp;
    for (i = 1; i &lt; n; ++i) {   //由于temp的初值为第二个数，故i为1
        temp = s[i];
        for (j = i - 1; j &gt;= 0; j--) {
            if (s[j] &gt; temp) {
                s[j + 1] = s[j];
            } else {
                break;
            }
        }
        s[j + 1] = temp;
    }
    return 0;
}

int main(void) {
    int a[10], i;
    printf(&quot;请输入10个数：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    insort(a, 10);
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; ++i) {
        printf(&quot;%5d&quot;, a[i]);    //将排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
25 12 36 45 2 9 39 22 98 37
排序后的顺序是：
    2    9   12   22   25   36   37   39   45   98
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>直接插入排序是将一个数与一组已排号顺序的序列中的最后一个数进行比较。直接插入排序是一种稳定的排序算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：6、冒泡排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example6/</id>
        <link href="https://acoldfront.github.io/post/c-example6/">
        </link>
        <updated>2020-05-05T04:19:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用冒泡排序法对任意输入的 10 个数按照从小到大的顺序进行排序。</p>
</blockquote>
<!-- more -->
<h3 id="算法描述">算法描述：</h3>
<p>冒泡排序是一种较为简单的排序算法，其基本思想为从头开始依次比较相邻的两个元素大小，将较大（较小）的元素移至右端，最终使最大（最小）的元素移至序列最后，再次重复上述过程，直到最终序列完全有序为止。</p>
<h3 id="算法执行过程分析">算法执行过程分析：</h3>
<p>例如：有一行数分别是26、10，83，56，28，66，7<br>
说明：按照从小到大的顺序进行排序，方框数为比较的次数，以下图示为比较完交换的结果。</p>
<p>(1)第一躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688650202.png" alt="" loading="lazy"><br>
此时已将此行数中最大的那个数字放在末尾。<br>
(2)第二躺排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688660796.png" alt="" loading="lazy"><br>
此时将倒数第二大的数字放在后面。<br>
(3)第三趟排序：<br>
<img src="https://acoldfront.github.io//post-images/1588688685619.png" alt="" loading="lazy"><br>
此时将倒数第三大的数字放在后面。<br>
以此类推，可以得到最终结果为：7、10、26、28、56、66、83。<br>
备注：n个数要比较n - 1趟，第一躺比较n - 1次，第 j 趟需要比较n - j 次。</p>
<p><strong>实现过程：</strong><br>
(1) 通过两个 for 循环实现冒泡排序的全过程，外层 for 循环决定冒泡排序的趟数，内层 for 循环决定每趟所进行两两比较的次数。</p>
<p>(2) 程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, tmp, a[10];    //定义变量及数组为基本整型
    printf(&quot;请输入10个数：\n&quot;);
    for (int i = 0; i &lt; 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);//从键盘中输入10个数
    }
    for (i = 1; i &lt; 10; ++i) {  //变量i代表比较的趟数
        for (j = 0; j &lt; 10 - i; ++j) {  //变最j代表每趟两两比较的次数
            if (a[j] &gt; a[j + 1]) {
                tmp = a[j]; //产利用中间变童实现两值互换
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }

    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //将冒泡排序后的顺序输出
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<hr>
<p><strong>改进版冒泡排序：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    //改进版冒泡排序
    int x, y, flag, tmp1, b[10];
    printf(&quot;请输入10个数：\n&quot;);
    for (int x = 0; x &lt; 10; ++x) {
        scanf(&quot;%d&quot;, &amp;b[x]);//从键盘中输入10个数
    }
    for (x = 1; x &lt; 10; ++x) {
        flag = 0;       //假设第x行没有交换数据，flag=0
        for (y = 0; y &lt; 10 - x; ++y) {
            if (b[y] &gt; b[y + 1]) {
                tmp1 = b[y];
                b[y] = b[y + 1];
                b[y + 1] = tmp1;
                flag = 1;   //交换数据，flag=1
            }
        }
        if (0 == flag) {    //若flag=0，表明第x行没有交换数据
            break;
        }
    }
    printf(&quot;排序后的顺序是：\n&quot;);
    for (x = 0; x &lt; 10; x++) {
        printf(&quot;%5d&quot;, b[x]);    //将冒泡排序后的顺序输出
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入10个数：
1 20 5 6 4 80 30 15 201 90
排序后的顺序是：
    1    4    5    6   15   20   30   80   90  201
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例要求用冒泡法对 10 个数由小到大进行排序，冒泡法的基本思路是，如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第 1 趟比较中要进行 n-j 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较。从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：5、希尔排序算法]]></title>
        <id>https://acoldfront.github.io/post/c-example5/</id>
        <link href="https://acoldfront.github.io/post/c-example5/">
        </link>
        <updated>2020-05-05T04:11:25.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用希尔排序法对一组数据由小到大进行排序，数据分别为 69、56、12、136、3、55、46、 99、88、25。</p>
</blockquote>
<!-- more -->
<p><strong>实现过程：</strong><br>
(1)自定义函数 shsort()，实现希尔排序。</p>
<p>(2) main() 函数作为程序的入口函数。程序代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int shsort(int s[], int n) {
    int i, j, d;
    d = n / 2;    //确定固定增虽值
    while (d &gt;= 1) {
        for (i = d + 1; i &lt;= n; ++i) {    //数组下标从d+1开始进行直接插入排序
            s[0] = s[i];  //设置监视哨
            j = i - d;  //确定要进行比较的元素的最右边位置
            while ((j &gt; 0) &amp;&amp; (s[0] &lt; s[j])) {
                s[j + d] = s[j];    //数据右移
                j = j - d;  //向左移d个位置
            }
            s[j + d] = s[0];    //在确定的位罝插入s[i]
        }
        d = d / 2;    //增里变为原来的一半
    }
    return 0;
}

int main(void) {
    int a[11], i;    //定义数组及变量为基本整型
    printf(&quot;请输入 10 个数据：\n&quot;);
    for (i = 1; i &lt;= 10; ++i) {
        scanf(&quot;%d&quot;, &amp;a[i]);  //从键盘中输入10个数据
    }
    shsort(a, 10);    //调用 shsort()函数
    printf(&quot;排序后的顺序是：\n&quot;);
    for (i = 1; i &lt;= 10; i++)
        printf(&quot;%5d&quot;, a[i]);    //输出排序后的数组
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入 10 个数据：
69 56 12 136 3 55 46 99 88 25
排序后的顺序是：
    3   12   25   46   55   56   69   88   99  136
</code></pre>
<hr>
<p>** 方法二 **</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void ShellSort(int a[], int n) {
    int i, j, temp;
    int flag, gap = n;
    while (gap &gt; 1) {
        gap = gap / 2;              //每次减半
        flag = 1;
        while (flag) {
            flag = 0;
            for (i = 0; i &lt; n - gap; i++) {
                j = i + gap;
                if (a[i] &gt; a[j]) {
                    temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                    flag = 1;
                }
            }
        }
    }
}

int main(void) {
    int a[10], i;
    printf(&quot;请输入 10 个数据：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    printf(&quot;排序前的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%-4d&quot;, a[i]);
    ShellSort(a, 10);
    printf(&quot;\n排序后的顺序是：\n&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot;%-4d&quot;, a[i]);
    printf(&quot;\n&quot;);
    return 0;
</code></pre>
<p>输出结果：</p>
<pre><code>请输入 10 个数据：
69 56 12 136 3 55 46 99 88 25
排序前的顺序是：
69  56  12  136 3   55  46  99  88  25
排序后的顺序是：
3   12  25  46  55  56  69  88  99  136
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>希尔排序是在直接插入排序的基础上做的改进，也就是将寒排序的序列按固定增量分成若干组，等距者在同二组中，然后再在组内进行直接插入排序。这里面的固定增量从 n/2 开始，以后每次缩小到原来的一半。<br>
<a href="https://blog.csdn.net/weixin_37818081/article/details/79202115">不懂希尔排序原理可以看</a></p>
]]></content>
    </entry>
</feed>