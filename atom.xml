<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acoldfront.github.io/</id>
    <title>Crazer的自留地</title>
    <updated>2020-09-08T13:59:17.419Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acoldfront.github.io/"/>
    <link rel="self" href="https://acoldfront.github.io/atom.xml"/>
    <subtitle>静坐长思己过，闲谈莫论人非</subtitle>
    <logo>https://acoldfront.github.io/images/avatar.png</logo>
    <icon>https://acoldfront.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Crazer的自留地</rights>
    <entry>
        <title type="html"><![CDATA[Bandizip(跨平台解压缩软件) v7.10 企业激活版]]></title>
        <id>https://acoldfront.github.io/post/bandizip/</id>
        <link href="https://acoldfront.github.io/post/bandizip/">
        </link>
        <updated>2020-09-08T08:53:47.000Z</updated>
        <summary type="html"><![CDATA[<p>虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p>
]]></summary>
        <content type="html"><![CDATA[<p>虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p>
<!-- more -->
<h3 id="主要功能">主要功能</h3>
<hr>
<p>支持操作系统: Windows Vista/7/8/10 (x86/x64/ARM64)<br>
许可类型：免费软件(EULA)<br>
全能的压缩/解压/浏览/编辑软件<br>
可提取30多种格式，包括RAR/RAR5/7Z/ZIP等<br>
包含密码压缩和分卷压缩功能<br>
支持多核高速压缩</p>
<h3 id="压缩">压缩</h3>
<hr>
<p>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7), ISO(joliet), GZ, XZ<br>
ZIP文件修改（添加/删除/重命名）<br>
支持多核并行，压缩速度可提升至多达6倍<br>
加密压缩<br>
支持AES256加密算法<br>
支持4GB 以上大小的文件压缩<br>
对ZIP格式支持Unicode或MBCS文件名<br>
对ZIP/7z格式可进行分卷压缩</p>
<h3 id="解压">解压</h3>
<hr>
<p>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ, IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ, TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ<br>
轻松查看压缩包内文件<br>
可只解压选定文件，支持拖拽解压<br>
可对ZIP和RAR格式添加注释<br>
一步解压TGZ/TBZ格式的文件</p>
<h3 id="功能多样">功能多样</h3>
<hr>
<p>测试文件完整性以确定压缩包是否损坏<br>
支持修改代码页改<br>
可集成至资源管理器右键菜单<br>
<img src="https://acoldfront.github.io//post-images/1587459441655.png" alt="" loading="lazy"></p>
<h3 id="更新日志">更新日志</h3>
<hr>
<p><a href="https://www.bandisoft.com/bandizip/history/">https://www.bandisoft.com/bandizip/history/</a></p>
<h3 id="破解教程">破解教程</h3>
<hr>
<p>7系列版本，安装后，下载破解补丁，破解后，使用激活码如下激活码</p>
<p>20380808-ENT000002-0E34A52561-166371E0</p>
<p>20380808-PRO0BFAEBFDAE23C425E-173E2DF1</p>
<p>邮箱地址：可任意填写，即随意填个假冒邮箱格式</p>
<p><a href="https://pan.baidu.com/s/11b-QgNy7bSagcZAbaL1Ggg">链接: https://pan.baidu.com/s/11b-QgNy7bSagcZAbaL1Ggg 提取码: jpfu</a></p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p>Bandizip各版本功能比较（自v7.0开始分为标准版/专业版/企业版）<br>
<a href="https://www.bandisoft.com/bandizip/help/edition-comparison">https://www.bandisoft.com/bandizip/help/edition-comparison</a></p>
<p>官网下载<br>
6系列版本：【原生无广告】<br>
<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE">安装版：https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE</a></p>
<p><a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP">32位便携版：https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP</a></p>
<p><a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP">64位便携版：https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP</a></p>
<p>7系列版本：<br>
<a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE">安装版：http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[思维导图软件 XMind ZEN 2020 v10.2.1 全平台 完美破解版]]></title>
        <id>https://acoldfront.github.io/post/xmind-zen-2020/</id>
        <link href="https://acoldfront.github.io/post/xmind-zen-2020/">
        </link>
        <updated>2020-07-31T22:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>XMind ZEN是一款有颜值的思维导图软件，新版本的软件界面比起老版本好看多了，作为一款electron开发出来的软件，自然支持几个端了，支持Windows和Mac版本。</p>
<!-- more -->
<p>XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。</p>
<p>这两年思维导图突然就火起来了，各种思维导图软件也是雨后春笋般冒出来了，自 Xmind 发布以来就受到全球多个国家的办公一族喜爱。而 XMind 开发团队成员也在不断的去改进产品以提供优秀的生产力工具和服务，帮助人们节省时间并提升效率为目标。<br>
<img src="https://acoldfront.github.io//post-images/1579860380835.png" alt="" loading="lazy"></p>
<p>全新内核，经典 XMind 体验。<br>
我们努力了3年，100% 重写了思维导图引擎的每一个细节，XMind: ZEN 对 XMind 8 做到了完全兼容，让你有一种全新却不失经典的体验。</p>
<p>无人可超越，只有超越自己。<br>
对所有主题进行了重新设计，为您的每一张导图都注入新的活力。字体渲染也得到了极大的改进，让每一张思维导图既美观又专业。</p>
<p>我们专注，为了让您更专注。<br>
ZEN 模式，寓意为禅。让专注变成一种习惯。</p>
<p>全新 Snowbrush 引擎<br>
我们努力了3年，100% 重写了思维导图的引擎，着眼在未来的黑科技上，提升了思维导图的展示效果，丰富了绘图的元素。</p>
<p>充满惊喜的主题<br>
XMind: ZEN 对所有主题进行了重新设计，为您的每一张导图都注入新的活力，专业的同时又不失丰富元素，好看到让人羡慕。</p>
<p>Font Rendering<br>
由于极大地改进了字体的渲染技术，无论你用 Mac 还是 Windows 创建思维导图，所有文字都以同一样式清晰呈现。XMind: ZEN 精选多款优质字体，爱上编辑导图，从未如此简单。</p>
<p>Markdown<br>
我们相信 Markdown 会为你带来更好的使用体验，将做好的图导出为 Markdown 格式后，会让你更易于阅读。</p>
<p>集专注于 ZEN 模式<br>
ZEN 模式，寓意为禅，让专注变成一种习惯。进入 ZEN 模式，隐藏页面内多余的元素，帮助你全神贯注地绘制每一个主题，心无旁骛地完成工作。</p>
<p>贴纸，原创的更好<br>
设计师原创的贴纸，每一个都精心绘制，更准确地满足你的需求，精彩无处不在。</p>
<p>100% 对 XMind 8 兼容<br>
XMind: ZEN 对 XMind 8 做到了完全兼容，所有 XMind 8 拥有的图形结构，在 XMind: ZEN 中都能完美展现。</p>
<p>导出PDF和印象笔记<br>
将思维导图导出为矢量的 PDF 文件，方便您将导图随意放大和清晰地打印。印象笔记的粉丝们还会惊喜地发现只需简单地点击，便可将导图分享到印象笔记中。</p>
<h2 id="更新日志">###更新日志</h2>
<p>10.2.1</p>
<p>重大更新</p>
<ol>
<li>整体流畅度和打开大图的速度大幅提升；</li>
<li>括号图——一种描述整体和局部关系的新结构；</li>
<li>创建风格——直接基于当前导图的风格来创建自定义风格；</li>
<li>快捷键增强——更丰富的快捷键设置，包括大纲模式的快捷键；</li>
<li>合并 XMind 文件——将所有的点子聚合到一个文件里。<br>
优化与提升</li>
<li>新增了一批有趣实用的贴纸；</li>
<li>工具栏新增“插入”按钮，插入元素更加直观便捷；</li>
<li>支持在导出的 PDF/SVG 中点击插入的网页链接；</li>
<li>增大了笔记的编辑框；</li>
<li>笔记和链接的编辑框支持弹出右键菜单；</li>
<li>新增了跳转到搜索结果时的高亮动画；</li>
<li>全面优化了法语和繁体中文的文案；</li>
<li>优化了非英语字体名称的显示效果；</li>
<li>优化了快速样式列表的预览效果；</li>
<li>优化了在画布空白处点击右键的菜单内容；</li>
<li>优化了一些 UI 细节；</li>
<li>修复了大纲模式下可能会将元素插入到错误的主题上的问题；</li>
<li>修复了导出 PNG/SVG 时，联系线箭头方向可能错误的问题；</li>
<li>修复了由于特殊字符，分享到 Evernote 失败的问题；</li>
<li>修复了 Windows 下按 CAPS LOCK 可能会清空主题文字的问题；</li>
<li>修复了在笔记里撤销后，内容可能会变成另一条笔记的问题；</li>
<li>修复了点击联系和外框的搜索结果无法跳转到对应元素的问题；</li>
<li>修复了大纲模式下会显示联系和外框的搜索结果的问题；</li>
<li>修复了风格编辑器中调整外框的边框颜色失效的问题；</li>
<li>修复了 ZEN 模式下重命名画布时，画布栏消失的问题；</li>
<li>修复了树形图结构下，导出 PDF 的画面不完整的问题；</li>
<li>修复了特殊情况下，导出 PNG 的画面不完整的问题；</li>
<li>修复了部分其他已知问题。</li>
</ol>
<h3 id="修改说明">修改说明</h3>
<hr>
<p>基于官网最新版本破解</p>
<p>破解授权，移除验证，去除试用提示</p>
<p>能正常导出图片无水印，PDF无水印，导出word，粘贴图片等高级功能</p>
<p>v2版本导出PNG缩放大小已修复</p>
<h3 id="使用提示">使用提示</h3>
<hr>
<p>将app.asar放入XMind-ZEN安装目录的resources文件夹下替换</p>
<h3 id="下载地址">下载地址</h3>
<hr>
<p><a href="https://pan.baidu.com/s/1Z6vMyM1__RwFOFALs0_s4w">链接: https://pan.baidu.com/s/1Z6vMyM1__RwFOFALs0_s4w 提取码: b4nd</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：25、矩阵转置]]></title>
        <id>https://acoldfront.github.io/post/c-example25/</id>
        <link href="https://acoldfront.github.io/post/c-example25/">
        </link>
        <updated>2020-05-08T16:51:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例是利用数组解决线性代数中的矩阵转置问题。</p>
</blockquote>
<p>设有一矩阵为 m×n 阶（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，需要将该矩阵转置为 n×m 阶的矩阵，使其中元素满足 b(j,i)=a(i,j)。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例是利用数组解决线性代数中的矩阵转置问题。</p>
</blockquote>
<p>设有一矩阵为 m×n 阶（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，需要将该矩阵转置为 n×m 阶的矩阵，使其中元素满足 b(j,i)=a(i,j)。</p>
<!-- more -->
<p><strong>算法思想：</strong></p>
<p>由数学知识可知，将第一个矩阵的所有元素绕着一条从第一行第一列出发的右下角 45° 的射线做镜面反转，即可得到该矩阵的转置。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, j, i1, j1, a[101][101], b[101][101];
    printf(&quot;please input the number of rows(&lt;=100)\n&quot;);
    scanf(&quot;%d&quot;, &amp;i1);
    printf(&quot;please input the number of columns(&lt;=100)\n&quot;);
    scanf(&quot;%d&quot;, &amp;j1);
    printf(&quot;please input the element\n&quot;);
    for (i = 0; i &lt; i1; i++)
        for (j = 0; j &lt; j1; j++)
            scanf(&quot;%d&quot;, &amp;a[i][j]);
    printf(&quot;array a：\n&quot;);
    for (i = 0; i &lt; i1; i++) {
        for (j = 0; j &lt; j1; j++)
            printf(&quot;\t%d&quot;, a[i][j]);
        printf(&quot;\n&quot;);
    }
    for (i = 0; i &lt; i1; i++)
        for (j = 0; j &lt; j1; j++)
            b[j][i] = a[i][j];
    printf(&quot;array b：\n&quot;);
    for (i = 0; i &lt; j1; i++) {
        for (j = 0; j &lt; i1; j++)
            printf(&quot;\t%d&quot;, b[i][j]);
        printf(&quot;\n&quot;);
    }

    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>please input the number of rows(&lt;=100)
3
please input the number of columns(&lt;=100)
4
please input the element
1 2 3 4 5 6 7 8 9 10 11 12
array a：
        1       2       3       4
        5       6       7       8
        9       10      11      12
array b：
        1       5       9
        2       6       10
        3       7       11
        4       8       12

</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>在本实例中，主要运用了二维数组，二维数组的使用说明如下：</p>
<p>① 二维数组的第一个下标表示行数，第二个下标表示列数，每个下标都是从 0 开始；</p>
<p>② 类型说明符、数组名和常量表达式的意义与一维数组相同；</p>
<p>③ 二维数组的元素在内存中是“按行存放”，即在内存中先顺序存放第一行的元素，再存放第二行的元素，以此类推；</p>
<p>④ 可以把二维数组看作一种特殊的一维数组，其特殊之处在于它的每一个元素又是一维数组。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：24、获取矩阵的最大值及其下标]]></title>
        <id>https://acoldfront.github.io/post/c-example24/</id>
        <link href="https://acoldfront.github.io/post/c-example24/">
        </link>
        <updated>2020-05-08T16:43:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本实例要求使用二维数组将一个 3×4 的矩阵中所有元素的最大值及其下标获取，通过该程序，掌握二维数组的引用知识。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本实例要求使用二维数组将一个 3×4 的矩阵中所有元素的最大值及其下标获取，通过该程序，掌握二维数组的引用知识。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong></p>
<p>针对本实例，有两个步骤需要编写程序完成：第一个步骤是求矩阵元素的最大值，可以通过相邻的元素大小比较，最终获取最大值；第二个步骤是针对获取到的元素最大值，求该元素的下标。</p>
<p>二维数组元素的一般表示方法为：“数组名[下标][下标]”。对于二维数组，下标变量和数组说明在表示形式上是一样的，比如在本例中，有语句：int a[3][4]; a[3][4]=2/3;</p>
<p>上述语句中“a[3][4]”是完全不同的两个概念，第一个语句中的“a[3][4]”用来定义一个数组，而第二个语句中的“a[3][4]”是一个双下标变量。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int a[3][4], i, j, max, max_i = 0, max_j = 0;
    for (i = 0; i &lt; 3; ++i) {
        for (j = 0; j &lt; 4; ++j) {
            scanf(&quot;%d&quot;,&amp;a[i][j]);
        }
    }
    max=a[0][0];
    for (i = 0; i &lt; 3; ++i) {
        for (j = 0; j &lt; 4; ++j) {
            if(a[i][j]&gt;max){
                max=a[i][j];
                max_i=i;
                max_j=j;
            }
        }
    }
    printf(&quot;max=a[%d][%d]=%d\n&quot;,max_i,max_j,max);

    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>1 2 3 4 5 6 7 99 9 10 11 12
max=a[1][3]=99
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实训的程序主要完成了两个功能：一是通过一个二次循环输入该二维数组的所有元素；二是将输入元素按照相邻关系进行比较，最终得到最大值和这个最大值的下标。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：23、谁家孩子跑得最慢]]></title>
        <id>https://acoldfront.github.io/post/c-example23/</id>
        <link href="https://acoldfront.github.io/post/c-example23/">
        </link>
        <updated>2020-05-08T16:39:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>张、王、李三家各有三个小孩。一天，三家的九个孩子在一起比赛短跑，规定不分年龄大小，跑第一得 9 分，跑第二得 8 分，依次类推。比赛结果显示各家的总分相同，且这些孩子没有同时到达终点的，也没有一家的两个或三个孩子获得相连的名次。已知获第一名的是李家的孩子，获第二名的是王家的孩子。获得最后一名的是谁家的孩子？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>张、王、李三家各有三个小孩。一天，三家的九个孩子在一起比赛短跑，规定不分年龄大小，跑第一得 9 分，跑第二得 8 分，依次类推。比赛结果显示各家的总分相同，且这些孩子没有同时到达终点的，也没有一家的两个或三个孩子获得相连的名次。已知获第一名的是李家的孩子，获第二名的是王家的孩子。获得最后一名的是谁家的孩子？</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
按题目的条件，共有 1+2+3+…+9=45 分，每家孩子的得分应为 15 分。根据题意可知，获第一名的是李家的孩子，获第二名的是王家的孩子，则可推出：获第三名的一定是张家的孩子。由“这些孩子没有同时到达终点的”可知：名次不能并列，由“没有一家的两个或三个孩子获得相连的名次”可知：第四名不能是张家的孩子。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int score[4][4];

int main(void) {
    int i, j, k, who;
    score[1][1] = 7;
    score[2][1] = 8;
    score[3][1] = 9;
    for (i = 4; i &lt; 6; i++)
        for (j = 4; j &lt; 7; j++)
            for (k = 4; i != j &amp;&amp; k &lt; 7; k++)
                if (k != i &amp;&amp; k != j &amp;&amp; 15 - i - score[1][1] != 15 - j - score[2][1]
                    &amp;&amp; 15 - i - score[1][1] != 15 - k - score[3][1]
                    &amp;&amp; 15 - j - score[2][1] != 15 - k - score[3][1]) {
                    score[1][2] = i;
                    score[1][3] = 15 - i - 7;
                    score[2][2] = j;
                    score[2][3] = 15 - j - 8;
                    score[3][2] = k;
                    score[3][3] = 15 - k - 9;
                }
    for (who = 0, i = 1; i &lt;= 3; i++, printf(&quot;\n&quot;))
        for (j = 1; j &lt;= 3; j++) {
            printf(&quot;%d&quot;, score[i][j]);
            if (score[i][j] == 1)
                who = i;
        }
    if (who == 1)
        printf(&quot;最后一名是张家孩子\n&quot;);
    else if (who == 2)
        printf(&quot;最后一名是王家孩子\n&quot;);
    else
        printf(&quot;最后一名是李家孩子\n&quot;);
    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>753
861
942
最后一名是王家孩子
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>本实例主要运用了二维数组的引用和循环的嵌套。二维数组元素的引用形式为“数组名[下标1][下标2]”。例如“a[1][2]”其下标是可以大于或者等于 0 的整型常量、整型变量或者整型表达式。</p>
<p>引用二维数组元素时，下标不要越界，也就是说下标值需要从 0 开始，但不要超过行、列的范围。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：22、狼追兔子]]></title>
        <id>https://acoldfront.github.io/post/c-example22/</id>
        <link href="https://acoldfront.github.io/post/c-example22/">
        </link>
        <updated>2020-05-08T16:37:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一只兔子躲进了 10 个环形分布的洞的某一个，狼在第一个洞没有找到兔子，就隔一个洞，到第三个洞去找，也没有找到，就隔两个洞，到第六个洞去找，以后每次多隔一个洞 去找兔子……这样下去，结果一直找不到兔子，请问：兔子可能躲在哪个洞中？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一只兔子躲进了 10 个环形分布的洞的某一个，狼在第一个洞没有找到兔子，就隔一个洞，到第三个洞去找，也没有找到，就隔两个洞，到第六个洞去找，以后每次多隔一个洞 去找兔子……这样下去，结果一直找不到兔子，请问：兔子可能躲在哪个洞中？</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
对于本实例中提到的问题，虽然是“兔子可能躲在哪个洞中”，但是在考虑算法时，需要知道的是狼会去哪个洞找兔子，狼第一次去的洞是第一个（表示为 pos1），第二次去的是第三个（pos3），把它去的洞的代码用数字表示出来，可以推导出狼去的洞的代码是： pos(i+1)=pos(i)+i+1。</p>
<p>由题目可知，狼没有找到兔子，因此该算法会一直持续下去。除此之外，还需要注意的是，在 10 个洞之后，比如狼去找第十五个洞，但第十五个洞是不存在的，因此我们用 15 对 10 求余，得到的数字才是洞的标示。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i;
    bool pos[10] = {0};
    int lang = 0;
    for (i = 0; i &lt; 100; ++i) {
        pos[lang] = true;
        lang++;
        lang += i;
        lang = lang % 10;
    }
    for (i = 0; i &lt; 10; ++i) {
        if (!pos[i])
            printf(&quot;兔子可能在第%d洞中\n&quot;, i + 1);
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>兔子可能在第3洞中
兔子可能在第5洞中
兔子可能在第8洞中
兔子可能在第10洞中
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>(1) 一维数组定义时需要注意的规则：<br>
① 数组名的命名规则遵守标识符的命名规则。<br>
② 常量表达式指出数组的长度，当长度为 n 时，即数组为 n 个元素，数组元素下标范围只能是 0~（n—1），即数组中第一个元素的下标为 0，数组中最后一个元素的下标应该是（n—1）。<br>
③ 常量表达式可以包含常量和符号常量，但是不能包含变量。<br>
④ 在定义数组的说明中，可以有多个数组说明符，用逗号隔开即可。</p>
<p>(2) 一维数组的引用说明：<br>
① 数组下标可以是整型常量、整型变量或者整型表达式，初始值为 0。<br>
② 一个数组元素引用的实质就是一个变量名的引用，每一个数组元素代表内存中的一个存储单元，具有与相同类型单个变量一样的属性，可以对它进行赋值且参与各种运算，一个数组占有一段连续的存储单元。<br>
③ 在 C 语言中，数组不能作为一个整体参加数据运算，只能对单个元素进行计算。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：21、斐波那契、兔子生兔子]]></title>
        <id>https://acoldfront.github.io/post/c-example21/</id>
        <link href="https://acoldfront.github.io/post/c-example21/">
        </link>
        <updated>2020-05-08T04:15:22.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。<br>
假设一对兔子的成熟期是一个月，即一个月可长成成兔，那么，如果每对成兔每个月都生一对小兔，一对新生的小兔从第二个月起就开始生兔子，试问从一对兔子开始繁殖，以后每个月会有多少对兔子？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。<br>
假设一对兔子的成熟期是一个月，即一个月可长成成兔，那么，如果每对成兔每个月都生一对小兔，一对新生的小兔从第二个月起就开始生兔子，试问从一对兔子开始繁殖，以后每个月会有多少对兔子？</p>
</blockquote>
<!-- more -->
<pre><code class="language-c">#include &lt;stdio.h&gt;

//斐波那契数列 这个数列从第3项开始，每一项都等于前两项之和。

int main(void) {
    int n = 0;
    printf(&quot;请输入一个数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);

    //若要打印 斐波那契数列
    int f1 = 1, f2 = 1, f3, i;
    printf(&quot;%8d%8d&quot;, f1, f2);
    for (i = 3; i &lt;= n; i++) {
        f3 = f1 + f2;
        printf(&quot;%8d&quot;, f3);
        f1 = f2;
        f2 = f3;
    }
    return 0;
}



</code></pre>
<p>输出结果：</p>
<pre><code>请输入一个数：5
       1       1       2       3       5
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>(1) 实例分析<br>
循环的嵌套是指在一个循环体内又包含了另一个完整的循环。循环的嵌套执行过程是外循环执行一次，内循环执行一次，在内循环结束后，再执行下一次外循环，如此反复，直到外循环结束。</p>
<p>(2) 循环的嵌套注意事项：<br>
① 循环必须完全包含内循环，不能交叉；<br>
② 在多重循环中，各层循环的循环控制变量不能同名；<br>
③ 在多重循环中，并列循环的循环控制变量名可以相同，也可以不同。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：20、判断闰年，即判断年份是否为闰年]]></title>
        <id>https://acoldfront.github.io/post/c-example20/</id>
        <link href="https://acoldfront.github.io/post/c-example20/">
        </link>
        <updated>2020-05-06T09:49:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>实例要求从键盘输入任意年份的整数 N，通过程序运行判断该年份是否为闰年。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
判断任意年份是否为闰年，需要满足以下条件中的任意一个：<br>
① 该年份能被 4 整除同时不能被 100 整除；<br>
② 该年份能被400整除。</p>
<p>本实例中使用嵌入式 if-else 语句。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int year, a;
    printf(&quot;请输人年份：&quot;);
    scanf(&quot;%d&quot;, &amp;year);
    if (((year % 4 == 0 )&amp;&amp; (year % 100 != 0)) || (year % 400 == 0))
        printf(&quot;%d 此年是闰年\n&quot;, year);
    else
        printf(&quot;%d 此年非闰年\n&quot;,year);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输人年份：1995
1995 此年非闰年

请输人年份：1996
1996 此年是闰年
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：19、求回文数、回文素数]]></title>
        <id>https://acoldfront.github.io/post/c-example19/</id>
        <link href="https://acoldfront.github.io/post/c-example19/">
        </link>
        <updated>2020-05-06T08:58:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>任意的整数，当从左向右读与从右向左读是相同的，且为素数时，称为回文素数。<br>
输入一个整数判断是否是回文数</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
① 获取一个数，例如123<br>
② 求出321与123相比<br>
③ 求123中的个位数：3 -&gt; 123%10/1<br>
十位数：2 -&gt; 123%100/10<br>
百位数：1 -&gt; 123%1000/100<br>
通式：num  %(10*i)/i<br>
④将321 = 3 * 100 +2  * 10 + 1<br>
⑤定义一个snum用来存储倒置的数，即：snum = 321，snum = num % (10 * i) / i + 10 * snum;<br>
第一次循环：s = 3 + 0<br>
第二次循环：s = 2 + 30<br>
第三次循环：s = 1 + 320<br>
⑥对比num 和 snum的值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    int i, num;
    int snum = 0;   //用来存放倒置的数
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;num);
    for (i = 1; i &lt; num; i *= 10) {   //i每次增加10倍，实现个位，十位，百位。。。的转化换
        snum = num % (10 * i) / i + 10*snum;
        //s = 3 + 0
        //s = 2 + 30
        //s = 1 + 320
    }
    if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);if (num == snum)
        printf(&quot;这个数是一个回文数\n&quot;);
    else
        printf(&quot;这个数不是一个回文数\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>请输入一个整数：121
这个数是一个回文数
</code></pre>
<hr>
<blockquote>
<p>求 1000 以内的所有回文素数。</p>
</blockquote>
<p><strong>算法思想：</strong><br>
实例的重点是判断一个数是否是回文素数。要输出 1000 以内的所有回文素数，首先应判断这个数是否是素数；如果是，再进一步判断这个数是两位数还是三位数，若是两位数，则需判断个位数和十位数是否相同；若是三位数，则需判断个位数和百位数是否相同。若相同，则判断为回文素数，否则继续下次判断。</p>
<p>① 定义一个函数 sushu，其作用是判断一个数是否是素数。<br>
② 对判断为素数的数，再判断其是否是两位数。<br>
若是两位数，再判断其个位数和十位数是否相同，若相同则打印输出；若不相同，则执行④；若不是两位数，则执行③。<br>
③ 若是三位数，则判断其个位数和百位数是否相同。若相同，则打印输出；若不相同，则执行 ④。<br>
④ 循环控制变量 i 自增 1。<br>
⑤ 直到 i 自增至 1000 结束。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;stdio.h&gt;

/*判断参数n是否为素数*/
int fun(int n) {
    int i;
    for (i = 2; i &lt; (n - 1) / 2; ++i) {
        if (n % i == 0)
            return 0;
    }
    return 1;
}

int main(void) {
    int i;
    for (i = 10; i &lt; 1000; ++i) {   //10以内没有回文素数
        if (fun(i) == 1) {      //素数
            if (i / 100 == 0) {     //100以内的
                if (i / 10 == i % 10)   //对比十位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);
            } else {
                if (i / 100 == i % 10)  //对比百位和个位
                    printf(&quot;%5d&quot;, i);
                if (i % 5 == 0)
                    printf(&quot;\n&quot;);

            }
        }
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>   11  101  131  151  181  191  313  353  373  383  727  757  787  797  919  929
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 程序由 main() 函数和 sushu() 函数组成，main() 函数调用 sushu() 函数，整型变量 i 为函数参数。当 sushu () 执行完后，返回到主函数中继续执行被调函数后面的语句。</p>
<p>② 函数调用语句由函数名、实际参数加上分号“;”组成。其一般形式为“函数名(实际参数表);”。执行函数语句就是调用函数体并把实际参数赋予函数定义中的形式参数，然后执行被调函数体中的语句，求取函数值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言编程实例：18、小写字母转换成大写字母]]></title>
        <id>https://acoldfront.github.io/post/c-example18/</id>
        <link href="https://acoldfront.github.io/post/c-example18/">
        </link>
        <updated>2020-05-06T08:56:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 C 语言中区分字母的大小写，利用 ASCII 码中大写字母和小写字母之间的转换关系（差值为 32），可以将小写字母转换为大写字母。编写程序实现，从键盘上输入一个小写字母，按回车键，程序将该小写字母转换为大写字母，并输出其 ASCII 值。</p>
</blockquote>
<!-- more -->
<p><strong>算法思想：</strong><br>
由于大写字母与小写字母之间的差值为 32，因此小写字母转换为大写字母的方法就是将小写字母的 ASCII 码值减去 32，便可得到与之对应的大写字母。</p>
<p>利用 getchar 函数从键盘上输入一个小写字母，并将其赋给一个字符变量 a；然后将 a—32 的值赋给字符变量 b；最后进行输出，输出时先输出字母，再将字母以整数形式输出。其具体步骤如下：</p>
<p>① 定义两个字符变量 a、b；<br>
② a=get char()；<br>
③ b=a—32；<br>
④ 打印输出。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    char a, b;
    printf(&quot;输入一个小写字母:\n&quot;);
    a = getchar();
    b = a - 32;
    printf(&quot;转换后的字母为：%c，%d\n&quot;, b, b);
    return 0;
}

</code></pre>
<p>输出结果：</p>
<pre><code>输入一个小写字母:
c
转换后的字母为：C，67
</code></pre>
<h3 id="技术要点">技术要点：</h3>
<p>① 实例内容要求对 ASCII 码有所了解。知道小写字母和大写字母之间的差值为 32。</p>
<p>② getchar 函数的功能是从键盘上输入一个字符。其一般形式为“getchar()”。通常把输入的字符赋予一个字符变量，构成赋值语句，如：char c;或c=getchar();</p>
<p>③ 使用 getchar 函数还应注意几个问题：<br>
getchar 函数只能接收单个字符，输入数字也按字符处理。输入多于一个字符时，只接收第一个字符。<br>
使用 getchar 函数前必须包含文件“stdio.h”。</p>
]]></content>
    </entry>
</feed>